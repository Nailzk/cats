{"version":3,"file":"45.b1dafe621cc26e19.js","mappings":"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","names":["i0","_MatProgressSpinnerBase","mixinColor","constructor","_elementRef","this","MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS","InjectionToken","providedIn","factory","diameter","BASE_SIZE","elementRef","_platform","_document","animationMode","defaults","changeDetectorRef","viewportRuler","ngZone","super","_diameter","_value","_resizeSubscription","Subscription","mode","trackedDiameters","MatProgressSpinner","_diameters","_spinnerAnimationLabel","_getSpinnerAnimationLabel","has","head","set","Set","_noopAnimations","_forceAnimations","nativeElement","nodeName","toLowerCase","strokeWidth","isBrowser","SAFARI","change","subscribe","run","markForCheck","size","coerceNumberProperty","_styleRoot","_attachStyleNode","_strokeWidth","value","newValue","Math","max","min","ngOnInit","element","_getShadowRoot","classList","add","ngOnDestroy","unsubscribe","_getCircleRadius","_getViewBox","viewBox","_getStrokeCircumference","PI","_getStrokeDashOffset","_getCircleStrokeWidth","_getCircleTransformOrigin","svg","_a","scale","currentScale","styleRoot","currentDiameter","diameters","diametersForElement","get","styleTag","createElement","setAttribute","textContent","_getAnimationText","appendChild","strokeCircumference","replace","toString","WeakMap","ɵfac","i1","DOCUMENT","ANIMATION_MODULE_TYPE","i2","ɵcmp","selectors","decls","directives","i3","styles","MatProgressSpinnerModule","ɵmod","ɵinj","MatCommonModule","CommonModule","_multiple","initiallySelectedValues","_emitChanges","_selection","_deselectedToEmit","_selectedToEmit","changed","Subject","length","forEach","_markSelected","selected","_selected","Array","from","values","select","_verifyValueAssignment","_emitChangeEvent","deselect","_unmarkSelected","toggle","isSelected","clear","_unmarkAll","isEmpty","hasValue","sort","predicate","isMultipleSelection","next","source","added","removed","push","delete","MAT_CHIP_REMOVE","MAT_CHIP_AVATAR","MAT_CHIP_TRAILING_ICON","_MatChipMixinBase","mixinTabIndex","mixinDisableRipple","MatChipBase","MatChip","_ngZone","platform","globalRippleOptions","_changeDetectorRef","tabIndex","_hasFocus","chipListSelectable","_chipListMultiple","_chipListDisabled","_selectable","_disabled","_removable","_onFocus","_onBlur","selectionChange","EventEmitter","destroyed","_addHostClassName","_chipRippleTarget","_chipRipple","RippleRenderer","setupTriggerEvents","rippleConfig","_animationsDisabled","parseInt","rippleDisabled","disabled","disableRipple","coercedValue","coerceBooleanProperty","_dispatchSelectionChange","undefined","selectable","removable","ariaSelected","basicChipAttrName","hasAttribute","tagName","emit","chip","_removeTriggerEvents","selectViaInteraction","toggleSelected","isUserInput","focus","remove","_handleClick","event","preventDefault","_handleKeydown","keyCode","DELETE","BACKSPACE","SPACE","_blur","onStable","pipe","take","MAT_RIPPLE_GLOBAL_OPTIONS","ɵdir","a","o","e","MAT_CHIPS_DEFAULT_OPTIONS","_MatChipListBase","mixinErrorState","_defaultErrorStateMatcher","_parentForm","_parentFormGroup","ngControl","nextUniqueId","MatChipList","_dir","controlType","_lastDestroyedChipIndex","_destroyed","_uid","_tabIndex","_userTabIndex","_onTouched","_onChange","_compareWith","o1","o2","ariaOrientation","valueChange","valueAccessor","_b","multiple","_selectionModel","role","empty","_syncChipsState","compareWith","fn","_initializeSelection","writeValue","id","_chipInput","required","_c","_d","_required","control","hasValidator","Validators","stateChanges","placeholder","_placeholder","focused","_hasFocusedChip","chips","shouldLabelFloat","chipSelectionChanges","merge","map","chipFocusChanges","chipBlurChanges","chipRemoveChanges","ngAfterContentInit","_keyManager","FocusKeyManager","withWrap","withVerticalOrientation","withHomeAndEnd","withHorizontalOrientation","takeUntil","dir","tabOut","_allowFocusEscape","changes","startWith","Promise","resolve","then","_resetChips","_updateTabIndex","_updateFocusForDestroyedChips","SelectionModel","ngDoCheck","updateErrorState","complete","_dropSubscriptions","registerInput","inputElement","setDescribedByIds","ids","_ariaDescribedby","join","_setSelectionByValue","registerOnChange","registerOnTouched","setDisabledState","isDisabled","onContainerClick","_originatesFromChip","options","setFirstItemActive","_focusInput","_keydown","target","contains","onKeydown","newChipIndex","setActiveItem","_isValidIndex","index","_clearSelection","isArray","currentValue","_selectValue","_sortValues","correspondingChip","find","skip","_propagateChanges","fallbackValue","valueToEmit","MatChipListChange","setTimeout","_markAsTouched","_listenToChipsFocus","_listenToChipsSelection","_listenToChipsRemoved","_chipFocusSubscription","_chipBlurSubscription","_chipSelectionSubscription","_chipRemoveSubscription","chipIndex","toArray","indexOf","updateActiveItem","currentElement","parentElement","some","i1$1","provide","MatFormFieldControl","useExisting","ngContentSelectors","MatChipsModule","ErrorStateMatcher","useValue","separatorKeyCodes","ENTER","imports","t","i","_panelDoneAnimatingStream","matSelectAnimations","transformPanelWrap","trigger","transition","query","animateChild","optional","transformPanel","state","style","transform","minWidth","opacity","animate","SELECT_PANEL_MAX_HEIGHT","MAT_SELECT_SCROLL_STRATEGY","MAT_SELECT_CONFIG","MAT_SELECT_SCROLL_STRATEGY_PROVIDER","deps","Overlay","useFactory","overlay","scrollStrategies","reposition","_MatSelectMixinBase","mixinDisabled","MAT_SELECT_TRIGGER","_MatSelectBase","_viewportRuler","_parentFormField","scrollStrategyFactory","_liveAnnouncer","_defaultOptions","_panelOpen","_triggerAriaLabelledBy","_destroy","_valueId","_overlayPanelClass","overlayPanelClass","_focused","_disableOptionCentering","disableOptionCentering","ariaLabel","optionSelectionChanges","defer","switchMap","option","onSelectionChange","openedChange","_openedStream","filter","_closedStream","typeaheadDebounceInterval","_typeaheadDebounceInterval","_scrollStrategyFactory","_scrollStrategy","hasAssigned","_assignValue","_id","distinctUntilChanged","_panelDoneAnimating","panelOpen","_initKeyManager","_resetOptions","newAriaLabelledby","_getTriggerAriaLabelledby","removeAttribute","_previousControl","ngOnChanges","withTypeAhead","close","open","_canOpen","_highlightCorrectOption","_isRtl","triggerValue","selectedOptions","viewValue","reverse","_handleOpenKeydown","_handleClosedKeydown","isArrowKey","DOWN_ARROW","UP_ARROW","LEFT_ARROW","RIGHT_ARROW","isOpenKey","manager","isTyping","hasModifierKey","altKey","previouslySelectedOption","selectedOption","announce","activeItem","_selectViaInteraction","A","ctrlKey","hasDeselectedOptions","opt","previouslyFocusedIndex","activeItemIndex","shiftKey","_onAttached","_overlayDir","positionChange","detectChanges","_positioningSettled","_getPanelTheme","color","setInactiveStyles","_selectOptionByValue","correspondingOption","error","ActiveDescendantKeyManager","withAllowedModifierKeys","panel","_scrollOptionIntoView","changedOrDestroyed","_onSelect","_stateChanges","wasSelected","b","sortComparator","_getChangeEvent","_getPanelAriaLabelledby","labelId","getLabelId","ariaLabelledby","_getAriaActiveDescendant","isOpen","i4","MAT_FORM_FIELD","i5","viewQuery","Lt","Bt","CdkConnectedOverlay","MatSelect","arguments","_scrollTop","_triggerFontSize","_transformOrigin","_offsetY","_positions","originX","originY","overlayX","overlayY","_calculateOverlayScroll","selectedIndex","scrollBuffer","maxScroll","itemHeight","_getItemHeight","_triggerRect","getBoundingClientRect","getComputedStyle","fontSize","_calculateOverlayPosition","overlayRef","overlayElement","labelCount","_countGroupLabelsBeforeOption","optionGroups","scrollTop","_getOptionScrollPosition","_calculateOverlayOffsetX","offsetX","MatSelectChange","overlayRect","viewportSize","getViewportSize","isRtl","paddingWidth","SELECT_MULTIPLE_PANEL_PADDING_X","SELECT_PANEL_PADDING_X","first","group","leftOverflow","left","rightOverflow","right","width","round","updatePosition","_calculateOverlayOffsetY","optionHeightAdjustment","height","maxOptionsDisplayed","floor","optionOffsetFromPanelTop","_getItemCount","_checkOverlayWithinViewport","topSpaceAvailable","top","bottomSpaceAvailable","bottom","panelHeightTop","abs","panelHeightBottom","totalPanelHeight","_adjustPanelUp","c","_adjustPanelDown","_getOriginBasedOnOption","distanceBelowViewport","distanceAboveViewport","items","panelHeight","scrollContainerHeight","selectedOptionOffset","SELECT_ITEM_HEIGHT_EM","MatOption","MAT_OPTGROUP","MAT_OPTION_PARENT_COMPONENT","Yt","i7","i8","changeDetection","MatSelectModule","OverlayModule","MatOptionModule","CdkScrollableModule","MatFormFieldModule","BUTTON_HOST_ATTRIBUTES","_MatButtonBase","MatButton","_focusMonitor","_animationMode","isRoundButton","_hasHostAttributes","isIconButton","attr","_getHostElement","DEFAULT_ROUND_BUTTON_COLOR","ngAfterViewInit","monitor","stopMonitoring","origin","focusVia","_isRippleDisabled","attributes","attribute","MatRipple","attrs","MatButtonModule","MatRippleModule","CategoriesModule","RouterModule","FormsModule","ReactiveFormsModule","MatIconModule","PAGE_LIMITS","CategoriesComponent","_categoriesRepository","_route","_router","pageLimit","_handlePageLimitChanges","_pageLimit","_initCategories","_subscribeOnRouteParams","queryParams","untilDestroyed","params","Number","n","limit","categoryId","category_ids","navigate","relativeTo","queryParamsHandling","getItems","val","categories","err","console","UntilDestroy","CardComponent","CatsComponent","_imagesRepository","_subscribeOnParamChanges","Object","_params","_loadImages","isLoading","cats","CatsModule","path","component"],"sourceRoot":"webpack:///","sources":["./node_modules/@angular/material/fesm2015/progress-spinner.mjs","./node_modules/@angular/cdk/fesm2015/collections.mjs","./node_modules/@angular/material/fesm2015/chips.mjs","./node_modules/@angular/material/fesm2015/select.mjs","./node_modules/@angular/material/fesm2015/button.mjs","./src/app/categories/categories.module.ts","./src/app/categories/constants/page-limit.constant.ts","./src/app/categories/categories.component.html","./src/app/categories/categories.component.ts","./src/app/cats/card/card.component.ts","./src/app/cats/card/card.component.html","./src/app/cats/cats.component.html","./src/app/cats/cats.component.ts","./src/app/cats/cats.module.ts"],"sourcesContent":["import { coerceNumberProperty } from '@angular/cdk/coercion';\nimport * as i1 from '@angular/cdk/platform';\nimport { _getShadowRoot } from '@angular/cdk/platform';\nimport * as i3 from '@angular/common';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Component, ChangeDetectionStrategy, ViewEncapsulation, Optional, Inject, Input, NgModule } from '@angular/core';\nimport { mixinColor, MatCommonModule } from '@angular/material/core';\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\nimport { Subscription } from 'rxjs';\nimport * as i2 from '@angular/cdk/scrolling';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Base reference size of the spinner.\n * @docs-private\n */\nconst BASE_SIZE = 100;\n/**\n * Base reference stroke width of the spinner.\n * @docs-private\n */\nconst BASE_STROKE_WIDTH = 10;\n// Boilerplate for applying mixins to MatProgressSpinner.\n/** @docs-private */\nconst _MatProgressSpinnerBase = mixinColor(class {\n    constructor(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n}, 'primary');\n/** Injection token to be used to override the default options for `mat-progress-spinner`. */\nconst MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS = new InjectionToken('mat-progress-spinner-default-options', {\n    providedIn: 'root',\n    factory: MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY,\n});\n/** @docs-private */\nfunction MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY() {\n    return { diameter: BASE_SIZE };\n}\n// .0001 percentage difference is necessary in order to avoid unwanted animation frames\n// for example because the animation duration is 4 seconds, .1% accounts to 4ms\n// which are enough to see the flicker described in\n// https://github.com/angular/components/issues/8984\nconst INDETERMINATE_ANIMATION_TEMPLATE = `\n @keyframes mat-progress-spinner-stroke-rotate-DIAMETER {\n    0%      { stroke-dashoffset: START_VALUE;  transform: rotate(0); }\n    12.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(0); }\n    12.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(72.5deg); }\n    25%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(72.5deg); }\n\n    25.0001%   { stroke-dashoffset: START_VALUE;  transform: rotate(270deg); }\n    37.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(270deg); }\n    37.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(161.5deg); }\n    50%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(161.5deg); }\n\n    50.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(180deg); }\n    62.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(180deg); }\n    62.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(251.5deg); }\n    75%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(251.5deg); }\n\n    75.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(90deg); }\n    87.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(90deg); }\n    87.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(341.5deg); }\n    100%    { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(341.5deg); }\n  }\n`;\n/**\n * `<mat-progress-spinner>` component.\n */\nclass MatProgressSpinner extends _MatProgressSpinnerBase {\n    constructor(elementRef, _platform, _document, animationMode, defaults, \n    /**\n     * @deprecated `changeDetectorRef`, `viewportRuler` and `ngZone`\n     * parameters to become required.\n     * @breaking-change 14.0.0\n     */\n    changeDetectorRef, viewportRuler, ngZone) {\n        super(elementRef);\n        this._document = _document;\n        this._diameter = BASE_SIZE;\n        this._value = 0;\n        this._resizeSubscription = Subscription.EMPTY;\n        /** Mode of the progress circle */\n        this.mode = 'determinate';\n        const trackedDiameters = MatProgressSpinner._diameters;\n        this._spinnerAnimationLabel = this._getSpinnerAnimationLabel();\n        // The base size is already inserted via the component's structural styles. We still\n        // need to track it so we don't end up adding the same styles again.\n        if (!trackedDiameters.has(_document.head)) {\n            trackedDiameters.set(_document.head, new Set([BASE_SIZE]));\n        }\n        this._noopAnimations =\n            animationMode === 'NoopAnimations' && !!defaults && !defaults._forceAnimations;\n        if (elementRef.nativeElement.nodeName.toLowerCase() === 'mat-spinner') {\n            this.mode = 'indeterminate';\n        }\n        if (defaults) {\n            if (defaults.diameter) {\n                this.diameter = defaults.diameter;\n            }\n            if (defaults.strokeWidth) {\n                this.strokeWidth = defaults.strokeWidth;\n            }\n        }\n        // Safari has an issue where the circle isn't positioned correctly when the page has a\n        // different zoom level from the default. This handler triggers a recalculation of the\n        // `transform-origin` when the page zoom level changes.\n        // See `_getCircleTransformOrigin` for more info.\n        // @breaking-change 14.0.0 Remove null checks for `_changeDetectorRef`,\n        // `viewportRuler` and `ngZone`.\n        if (_platform.isBrowser && _platform.SAFARI && viewportRuler && changeDetectorRef && ngZone) {\n            this._resizeSubscription = viewportRuler.change(150).subscribe(() => {\n                // When the window is resize while the spinner is in `indeterminate` mode, we\n                // have to mark for check so the transform origin of the circle can be recomputed.\n                if (this.mode === 'indeterminate') {\n                    ngZone.run(() => changeDetectorRef.markForCheck());\n                }\n            });\n        }\n    }\n    /** The diameter of the progress spinner (will set width and height of svg). */\n    get diameter() {\n        return this._diameter;\n    }\n    set diameter(size) {\n        this._diameter = coerceNumberProperty(size);\n        this._spinnerAnimationLabel = this._getSpinnerAnimationLabel();\n        // If this is set before `ngOnInit`, the style root may not have been resolved yet.\n        if (this._styleRoot) {\n            this._attachStyleNode();\n        }\n    }\n    /** Stroke width of the progress spinner. */\n    get strokeWidth() {\n        return this._strokeWidth || this.diameter / 10;\n    }\n    set strokeWidth(value) {\n        this._strokeWidth = coerceNumberProperty(value);\n    }\n    /** Value of the progress circle. */\n    get value() {\n        return this.mode === 'determinate' ? this._value : 0;\n    }\n    set value(newValue) {\n        this._value = Math.max(0, Math.min(100, coerceNumberProperty(newValue)));\n    }\n    ngOnInit() {\n        const element = this._elementRef.nativeElement;\n        // Note that we need to look up the root node in ngOnInit, rather than the constructor, because\n        // Angular seems to create the element outside the shadow root and then moves it inside, if the\n        // node is inside an `ngIf` and a ShadowDom-encapsulated component.\n        this._styleRoot = _getShadowRoot(element) || this._document.head;\n        this._attachStyleNode();\n        element.classList.add('mat-progress-spinner-indeterminate-animation');\n    }\n    ngOnDestroy() {\n        this._resizeSubscription.unsubscribe();\n    }\n    /** The radius of the spinner, adjusted for stroke width. */\n    _getCircleRadius() {\n        return (this.diameter - BASE_STROKE_WIDTH) / 2;\n    }\n    /** The view box of the spinner's svg element. */\n    _getViewBox() {\n        const viewBox = this._getCircleRadius() * 2 + this.strokeWidth;\n        return `0 0 ${viewBox} ${viewBox}`;\n    }\n    /** The stroke circumference of the svg circle. */\n    _getStrokeCircumference() {\n        return 2 * Math.PI * this._getCircleRadius();\n    }\n    /** The dash offset of the svg circle. */\n    _getStrokeDashOffset() {\n        if (this.mode === 'determinate') {\n            return (this._getStrokeCircumference() * (100 - this._value)) / 100;\n        }\n        return null;\n    }\n    /** Stroke width of the circle in percent. */\n    _getCircleStrokeWidth() {\n        return (this.strokeWidth / this.diameter) * 100;\n    }\n    /** Gets the `transform-origin` for the inner circle element. */\n    _getCircleTransformOrigin(svg) {\n        var _a;\n        // Safari has an issue where the `transform-origin` doesn't work as expected when the page\n        // has a different zoom level from the default. The problem appears to be that a zoom\n        // is applied on the `svg` node itself. We can work around it by calculating the origin\n        // based on the zoom level. On all other browsers the `currentScale` appears to always be 1.\n        const scale = ((_a = svg.currentScale) !== null && _a !== void 0 ? _a : 1) * 50;\n        return `${scale}% ${scale}%`;\n    }\n    /** Dynamically generates a style tag containing the correct animation for this diameter. */\n    _attachStyleNode() {\n        const styleRoot = this._styleRoot;\n        const currentDiameter = this._diameter;\n        const diameters = MatProgressSpinner._diameters;\n        let diametersForElement = diameters.get(styleRoot);\n        if (!diametersForElement || !diametersForElement.has(currentDiameter)) {\n            const styleTag = this._document.createElement('style');\n            styleTag.setAttribute('mat-spinner-animation', this._spinnerAnimationLabel);\n            styleTag.textContent = this._getAnimationText();\n            styleRoot.appendChild(styleTag);\n            if (!diametersForElement) {\n                diametersForElement = new Set();\n                diameters.set(styleRoot, diametersForElement);\n            }\n            diametersForElement.add(currentDiameter);\n        }\n    }\n    /** Generates animation styles adjusted for the spinner's diameter. */\n    _getAnimationText() {\n        const strokeCircumference = this._getStrokeCircumference();\n        return (INDETERMINATE_ANIMATION_TEMPLATE\n            // Animation should begin at 5% and end at 80%\n            .replace(/START_VALUE/g, `${0.95 * strokeCircumference}`)\n            .replace(/END_VALUE/g, `${0.2 * strokeCircumference}`)\n            .replace(/DIAMETER/g, `${this._spinnerAnimationLabel}`));\n    }\n    /** Returns the circle diameter formatted for use with the animation-name CSS property. */\n    _getSpinnerAnimationLabel() {\n        // The string of a float point number will include a period ‘.’ character,\n        // which is not valid for a CSS animation-name.\n        return this.diameter.toString().replace('.', '_');\n    }\n}\n/**\n * Tracks diameters of existing instances to de-dupe generated styles (default d = 100).\n * We need to keep track of which elements the diameters were attached to, because for\n * elements in the Shadow DOM the style tags are attached to the shadow root, rather\n * than the document head.\n */\nMatProgressSpinner._diameters = new WeakMap();\nMatProgressSpinner.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatProgressSpinner, deps: [{ token: i0.ElementRef }, { token: i1.Platform }, { token: DOCUMENT, optional: true }, { token: ANIMATION_MODULE_TYPE, optional: true }, { token: MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS }, { token: i0.ChangeDetectorRef }, { token: i2.ViewportRuler }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });\nMatProgressSpinner.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.3.0\", type: MatProgressSpinner, selector: \"mat-progress-spinner, mat-spinner\", inputs: { color: \"color\", diameter: \"diameter\", strokeWidth: \"strokeWidth\", mode: \"mode\", value: \"value\" }, host: { attributes: { \"role\": \"progressbar\", \"tabindex\": \"-1\" }, properties: { \"class._mat-animation-noopable\": \"_noopAnimations\", \"style.width.px\": \"diameter\", \"style.height.px\": \"diameter\", \"attr.aria-valuemin\": \"mode === \\\"determinate\\\" ? 0 : null\", \"attr.aria-valuemax\": \"mode === \\\"determinate\\\" ? 100 : null\", \"attr.aria-valuenow\": \"mode === \\\"determinate\\\" ? value : null\", \"attr.mode\": \"mode\" }, classAttribute: \"mat-progress-spinner mat-spinner\" }, exportAs: [\"matProgressSpinner\"], usesInheritance: true, ngImport: i0, template: \"<!--\\n  preserveAspectRatio of xMidYMid meet as the center of the viewport is the circle's\\n  center. The center of the circle will remain at the center of the mat-progress-spinner\\n  element containing the SVG.\\n-->\\n<!--\\n  All children need to be hidden for screen readers in order to support ChromeVox.\\n  More context in the issue: https://github.com/angular/components/issues/22165.\\n-->\\n<svg\\n  [style.width.px]=\\\"diameter\\\"\\n  [style.height.px]=\\\"diameter\\\"\\n  [attr.viewBox]=\\\"_getViewBox()\\\"\\n  preserveAspectRatio=\\\"xMidYMid meet\\\"\\n  focusable=\\\"false\\\"\\n  [ngSwitch]=\\\"mode === 'indeterminate'\\\"\\n  aria-hidden=\\\"true\\\"\\n  #svg>\\n\\n  <!--\\n    Technically we can reuse the same `circle` element, however Safari has an issue that breaks\\n    the SVG rendering in determinate mode, after switching between indeterminate and determinate.\\n    Using a different element avoids the issue. An alternative to this is adding `display: none`\\n    for a split second and then removing it when switching between modes, but it's hard to know\\n    for how long to hide the element and it can cause the UI to blink.\\n  -->\\n  <circle\\n    *ngSwitchCase=\\\"true\\\"\\n    cx=\\\"50%\\\"\\n    cy=\\\"50%\\\"\\n    [attr.r]=\\\"_getCircleRadius()\\\"\\n    [style.animation-name]=\\\"'mat-progress-spinner-stroke-rotate-' + _spinnerAnimationLabel\\\"\\n    [style.stroke-dashoffset.px]=\\\"_getStrokeDashOffset()\\\"\\n    [style.stroke-dasharray.px]=\\\"_getStrokeCircumference()\\\"\\n    [style.stroke-width.%]=\\\"_getCircleStrokeWidth()\\\"\\n    [style.transform-origin]=\\\"_getCircleTransformOrigin(svg)\\\"></circle>\\n\\n  <circle\\n    *ngSwitchCase=\\\"false\\\"\\n    cx=\\\"50%\\\"\\n    cy=\\\"50%\\\"\\n    [attr.r]=\\\"_getCircleRadius()\\\"\\n    [style.stroke-dashoffset.px]=\\\"_getStrokeDashOffset()\\\"\\n    [style.stroke-dasharray.px]=\\\"_getStrokeCircumference()\\\"\\n    [style.stroke-width.%]=\\\"_getCircleStrokeWidth()\\\"\\n    [style.transform-origin]=\\\"_getCircleTransformOrigin(svg)\\\"></circle>\\n</svg>\\n\", styles: [\".mat-progress-spinner{display:block;position:relative;overflow:hidden}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.cdk-high-contrast-active .mat-progress-spinner circle{stroke:CanvasText}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}\\n\"], directives: [{ type: i3.NgSwitch, selector: \"[ngSwitch]\", inputs: [\"ngSwitch\"] }, { type: i3.NgSwitchCase, selector: \"[ngSwitchCase]\", inputs: [\"ngSwitchCase\"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatProgressSpinner, decorators: [{\n            type: Component,\n            args: [{ selector: 'mat-progress-spinner, mat-spinner', exportAs: 'matProgressSpinner', host: {\n                        'role': 'progressbar',\n                        // `mat-spinner` is here for backward compatibility.\n                        'class': 'mat-progress-spinner mat-spinner',\n                        // set tab index to -1 so screen readers will read the aria-label\n                        // Note: there is a known issue with JAWS that does not read progressbar aria labels on FireFox\n                        'tabindex': '-1',\n                        '[class._mat-animation-noopable]': `_noopAnimations`,\n                        '[style.width.px]': 'diameter',\n                        '[style.height.px]': 'diameter',\n                        '[attr.aria-valuemin]': 'mode === \"determinate\" ? 0 : null',\n                        '[attr.aria-valuemax]': 'mode === \"determinate\" ? 100 : null',\n                        '[attr.aria-valuenow]': 'mode === \"determinate\" ? value : null',\n                        '[attr.mode]': 'mode',\n                    }, inputs: ['color'], changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, template: \"<!--\\n  preserveAspectRatio of xMidYMid meet as the center of the viewport is the circle's\\n  center. The center of the circle will remain at the center of the mat-progress-spinner\\n  element containing the SVG.\\n-->\\n<!--\\n  All children need to be hidden for screen readers in order to support ChromeVox.\\n  More context in the issue: https://github.com/angular/components/issues/22165.\\n-->\\n<svg\\n  [style.width.px]=\\\"diameter\\\"\\n  [style.height.px]=\\\"diameter\\\"\\n  [attr.viewBox]=\\\"_getViewBox()\\\"\\n  preserveAspectRatio=\\\"xMidYMid meet\\\"\\n  focusable=\\\"false\\\"\\n  [ngSwitch]=\\\"mode === 'indeterminate'\\\"\\n  aria-hidden=\\\"true\\\"\\n  #svg>\\n\\n  <!--\\n    Technically we can reuse the same `circle` element, however Safari has an issue that breaks\\n    the SVG rendering in determinate mode, after switching between indeterminate and determinate.\\n    Using a different element avoids the issue. An alternative to this is adding `display: none`\\n    for a split second and then removing it when switching between modes, but it's hard to know\\n    for how long to hide the element and it can cause the UI to blink.\\n  -->\\n  <circle\\n    *ngSwitchCase=\\\"true\\\"\\n    cx=\\\"50%\\\"\\n    cy=\\\"50%\\\"\\n    [attr.r]=\\\"_getCircleRadius()\\\"\\n    [style.animation-name]=\\\"'mat-progress-spinner-stroke-rotate-' + _spinnerAnimationLabel\\\"\\n    [style.stroke-dashoffset.px]=\\\"_getStrokeDashOffset()\\\"\\n    [style.stroke-dasharray.px]=\\\"_getStrokeCircumference()\\\"\\n    [style.stroke-width.%]=\\\"_getCircleStrokeWidth()\\\"\\n    [style.transform-origin]=\\\"_getCircleTransformOrigin(svg)\\\"></circle>\\n\\n  <circle\\n    *ngSwitchCase=\\\"false\\\"\\n    cx=\\\"50%\\\"\\n    cy=\\\"50%\\\"\\n    [attr.r]=\\\"_getCircleRadius()\\\"\\n    [style.stroke-dashoffset.px]=\\\"_getStrokeDashOffset()\\\"\\n    [style.stroke-dasharray.px]=\\\"_getStrokeCircumference()\\\"\\n    [style.stroke-width.%]=\\\"_getCircleStrokeWidth()\\\"\\n    [style.transform-origin]=\\\"_getCircleTransformOrigin(svg)\\\"></circle>\\n</svg>\\n\", styles: [\".mat-progress-spinner{display:block;position:relative;overflow:hidden}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.cdk-high-contrast-active .mat-progress-spinner circle{stroke:CanvasText}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}\\n\"] }]\n        }], ctorParameters: function () {\n        return [{ type: i0.ElementRef }, { type: i1.Platform }, { type: undefined, decorators: [{\n                        type: Optional\n                    }, {\n                        type: Inject,\n                        args: [DOCUMENT]\n                    }] }, { type: undefined, decorators: [{\n                        type: Optional\n                    }, {\n                        type: Inject,\n                        args: [ANIMATION_MODULE_TYPE]\n                    }] }, { type: undefined, decorators: [{\n                        type: Inject,\n                        args: [MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS]\n                    }] }, { type: i0.ChangeDetectorRef }, { type: i2.ViewportRuler }, { type: i0.NgZone }];\n    }, propDecorators: { diameter: [{\n                type: Input\n            }], strokeWidth: [{\n                type: Input\n            }], mode: [{\n                type: Input\n            }], value: [{\n                type: Input\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass MatProgressSpinnerModule {\n}\nMatProgressSpinnerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatProgressSpinnerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nMatProgressSpinnerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatProgressSpinnerModule, declarations: [MatProgressSpinner], imports: [MatCommonModule, CommonModule], exports: [MatProgressSpinner, MatCommonModule] });\nMatProgressSpinnerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatProgressSpinnerModule, imports: [[MatCommonModule, CommonModule], MatCommonModule] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatProgressSpinnerModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [MatCommonModule, CommonModule],\n                    exports: [MatProgressSpinner, MatCommonModule],\n                    declarations: [MatProgressSpinner],\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @deprecated Import `MatProgressSpinner` instead. Note that the\n *    `mat-spinner` selector isn't deprecated.\n * @breaking-change 8.0.0\n */\n// tslint:disable-next-line:variable-name\nconst MatSpinner = MatProgressSpinner;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS, MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY, MatProgressSpinner, MatProgressSpinnerModule, MatSpinner };\n","import { isObservable, of, Subject } from 'rxjs';\nimport * as i0 from '@angular/core';\nimport { Injectable, InjectionToken } from '@angular/core';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass DataSource {\n}\n/** Checks whether an object is a data source. */\nfunction isDataSource(value) {\n    // Check if the value is a DataSource by observing if it has a connect function. Cannot\n    // be checked as an `instanceof DataSource` since people could create their own sources\n    // that match the interface, but don't extend DataSource.\n    return value && typeof value.connect === 'function';\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** DataSource wrapper for a native array. */\nclass ArrayDataSource extends DataSource {\n    constructor(_data) {\n        super();\n        this._data = _data;\n    }\n    connect() {\n        return isObservable(this._data) ? this._data : of(this._data);\n    }\n    disconnect() { }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A repeater that destroys views when they are removed from a\n * {@link ViewContainerRef}. When new items are inserted into the container,\n * the repeater will always construct a new embedded view for each item.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nclass _DisposeViewRepeaterStrategy {\n    applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\n        changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n            let view;\n            let operation;\n            if (record.previousIndex == null) {\n                const insertContext = itemContextFactory(record, adjustedPreviousIndex, currentIndex);\n                view = viewContainerRef.createEmbeddedView(insertContext.templateRef, insertContext.context, insertContext.index);\n                operation = 1 /* INSERTED */;\n            }\n            else if (currentIndex == null) {\n                viewContainerRef.remove(adjustedPreviousIndex);\n                operation = 3 /* REMOVED */;\n            }\n            else {\n                view = viewContainerRef.get(adjustedPreviousIndex);\n                viewContainerRef.move(view, currentIndex);\n                operation = 2 /* MOVED */;\n            }\n            if (itemViewChanged) {\n                itemViewChanged({\n                    context: view === null || view === void 0 ? void 0 : view.context,\n                    operation,\n                    record,\n                });\n            }\n        });\n    }\n    detach() { }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A repeater that caches views when they are removed from a\n * {@link ViewContainerRef}. When new items are inserted into the container,\n * the repeater will reuse one of the cached views instead of creating a new\n * embedded view. Recycling cached views reduces the quantity of expensive DOM\n * inserts.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nclass _RecycleViewRepeaterStrategy {\n    constructor() {\n        /**\n         * The size of the cache used to store unused views.\n         * Setting the cache size to `0` will disable caching. Defaults to 20 views.\n         */\n        this.viewCacheSize = 20;\n        /**\n         * View cache that stores embedded view instances that have been previously stamped out,\n         * but don't are not currently rendered. The view repeater will reuse these views rather than\n         * creating brand new ones.\n         *\n         * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.\n         */\n        this._viewCache = [];\n    }\n    /** Apply changes to the DOM. */\n    applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\n        // Rearrange the views to put them in the right location.\n        changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n            let view;\n            let operation;\n            if (record.previousIndex == null) {\n                // Item added.\n                const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);\n                view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));\n                operation = view ? 1 /* INSERTED */ : 0 /* REPLACED */;\n            }\n            else if (currentIndex == null) {\n                // Item removed.\n                this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);\n                operation = 3 /* REMOVED */;\n            }\n            else {\n                // Item moved.\n                view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));\n                operation = 2 /* MOVED */;\n            }\n            if (itemViewChanged) {\n                itemViewChanged({\n                    context: view === null || view === void 0 ? void 0 : view.context,\n                    operation,\n                    record,\n                });\n            }\n        });\n    }\n    detach() {\n        for (const view of this._viewCache) {\n            view.destroy();\n        }\n        this._viewCache = [];\n    }\n    /**\n     * Inserts a view for a new item, either from the cache or by creating a new\n     * one. Returns `undefined` if the item was inserted into a cached view.\n     */\n    _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {\n        const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);\n        if (cachedView) {\n            cachedView.context.$implicit = value;\n            return undefined;\n        }\n        const viewArgs = viewArgsFactory();\n        return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);\n    }\n    /** Detaches the view at the given index and inserts into the view cache. */\n    _detachAndCacheView(index, viewContainerRef) {\n        const detachedView = viewContainerRef.detach(index);\n        this._maybeCacheView(detachedView, viewContainerRef);\n    }\n    /** Moves view at the previous index to the current index. */\n    _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {\n        const view = viewContainerRef.get(adjustedPreviousIndex);\n        viewContainerRef.move(view, currentIndex);\n        view.context.$implicit = value;\n        return view;\n    }\n    /**\n     * Cache the given detached view. If the cache is full, the view will be\n     * destroyed.\n     */\n    _maybeCacheView(view, viewContainerRef) {\n        if (this._viewCache.length < this.viewCacheSize) {\n            this._viewCache.push(view);\n        }\n        else {\n            const index = viewContainerRef.indexOf(view);\n            // The host component could remove views from the container outside of\n            // the view repeater. It's unlikely this will occur, but just in case,\n            // destroy the view on its own, otherwise destroy it through the\n            // container to ensure that all the references are removed.\n            if (index === -1) {\n                view.destroy();\n            }\n            else {\n                viewContainerRef.remove(index);\n            }\n        }\n    }\n    /** Inserts a recycled view from the cache at the given index. */\n    _insertViewFromCache(index, viewContainerRef) {\n        const cachedView = this._viewCache.pop();\n        if (cachedView) {\n            viewContainerRef.insert(cachedView, index);\n        }\n        return cachedView || null;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class to be used to power selecting one or more options from a list.\n */\nclass SelectionModel {\n    constructor(_multiple = false, initiallySelectedValues, _emitChanges = true) {\n        this._multiple = _multiple;\n        this._emitChanges = _emitChanges;\n        /** Currently-selected values. */\n        this._selection = new Set();\n        /** Keeps track of the deselected options that haven't been emitted by the change event. */\n        this._deselectedToEmit = [];\n        /** Keeps track of the selected options that haven't been emitted by the change event. */\n        this._selectedToEmit = [];\n        /** Event emitted when the value has changed. */\n        this.changed = new Subject();\n        if (initiallySelectedValues && initiallySelectedValues.length) {\n            if (_multiple) {\n                initiallySelectedValues.forEach(value => this._markSelected(value));\n            }\n            else {\n                this._markSelected(initiallySelectedValues[0]);\n            }\n            // Clear the array in order to avoid firing the change event for preselected values.\n            this._selectedToEmit.length = 0;\n        }\n    }\n    /** Selected values. */\n    get selected() {\n        if (!this._selected) {\n            this._selected = Array.from(this._selection.values());\n        }\n        return this._selected;\n    }\n    /**\n     * Selects a value or an array of values.\n     */\n    select(...values) {\n        this._verifyValueAssignment(values);\n        values.forEach(value => this._markSelected(value));\n        this._emitChangeEvent();\n    }\n    /**\n     * Deselects a value or an array of values.\n     */\n    deselect(...values) {\n        this._verifyValueAssignment(values);\n        values.forEach(value => this._unmarkSelected(value));\n        this._emitChangeEvent();\n    }\n    /**\n     * Toggles a value between selected and deselected.\n     */\n    toggle(value) {\n        this.isSelected(value) ? this.deselect(value) : this.select(value);\n    }\n    /**\n     * Clears all of the selected values.\n     */\n    clear() {\n        this._unmarkAll();\n        this._emitChangeEvent();\n    }\n    /**\n     * Determines whether a value is selected.\n     */\n    isSelected(value) {\n        return this._selection.has(value);\n    }\n    /**\n     * Determines whether the model does not have a value.\n     */\n    isEmpty() {\n        return this._selection.size === 0;\n    }\n    /**\n     * Determines whether the model has a value.\n     */\n    hasValue() {\n        return !this.isEmpty();\n    }\n    /**\n     * Sorts the selected values based on a predicate function.\n     */\n    sort(predicate) {\n        if (this._multiple && this.selected) {\n            this._selected.sort(predicate);\n        }\n    }\n    /**\n     * Gets whether multiple values can be selected.\n     */\n    isMultipleSelection() {\n        return this._multiple;\n    }\n    /** Emits a change event and clears the records of selected and deselected values. */\n    _emitChangeEvent() {\n        // Clear the selected values so they can be re-cached.\n        this._selected = null;\n        if (this._selectedToEmit.length || this._deselectedToEmit.length) {\n            this.changed.next({\n                source: this,\n                added: this._selectedToEmit,\n                removed: this._deselectedToEmit,\n            });\n            this._deselectedToEmit = [];\n            this._selectedToEmit = [];\n        }\n    }\n    /** Selects a value. */\n    _markSelected(value) {\n        if (!this.isSelected(value)) {\n            if (!this._multiple) {\n                this._unmarkAll();\n            }\n            this._selection.add(value);\n            if (this._emitChanges) {\n                this._selectedToEmit.push(value);\n            }\n        }\n    }\n    /** Deselects a value. */\n    _unmarkSelected(value) {\n        if (this.isSelected(value)) {\n            this._selection.delete(value);\n            if (this._emitChanges) {\n                this._deselectedToEmit.push(value);\n            }\n        }\n    }\n    /** Clears out the selected values. */\n    _unmarkAll() {\n        if (!this.isEmpty()) {\n            this._selection.forEach(value => this._unmarkSelected(value));\n        }\n    }\n    /**\n     * Verifies the value assignment and throws an error if the specified value array is\n     * including multiple values while the selection model is not supporting multiple values.\n     */\n    _verifyValueAssignment(values) {\n        if (values.length > 1 && !this._multiple && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getMultipleValuesInSingleSelectionError();\n        }\n    }\n}\n/**\n * Returns an error that reports that multiple values are passed into a selection model\n * with a single value.\n * @docs-private\n */\nfunction getMultipleValuesInSingleSelectionError() {\n    return Error('Cannot pass multiple values into SelectionModel with single-value mode.');\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class to coordinate unique selection based on name.\n * Intended to be consumed as an Angular service.\n * This service is needed because native radio change events are only fired on the item currently\n * being selected, and we still need to uncheck the previous selection.\n *\n * This service does not *store* any IDs and names because they may change at any time, so it is\n * less error-prone if they are simply passed through when the events occur.\n */\nclass UniqueSelectionDispatcher {\n    constructor() {\n        this._listeners = [];\n    }\n    /**\n     * Notify other items that selection for the given name has been set.\n     * @param id ID of the item.\n     * @param name Name of the item.\n     */\n    notify(id, name) {\n        for (let listener of this._listeners) {\n            listener(id, name);\n        }\n    }\n    /**\n     * Listen for future changes to item selection.\n     * @return Function used to deregister listener\n     */\n    listen(listener) {\n        this._listeners.push(listener);\n        return () => {\n            this._listeners = this._listeners.filter((registered) => {\n                return listener !== registered;\n            });\n        };\n    }\n    ngOnDestroy() {\n        this._listeners = [];\n    }\n}\nUniqueSelectionDispatcher.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: UniqueSelectionDispatcher, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nUniqueSelectionDispatcher.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: UniqueSelectionDispatcher, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: UniqueSelectionDispatcher, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token for {@link _ViewRepeater}. This token is for use by Angular Material only.\n * @docs-private\n */\nconst _VIEW_REPEATER_STRATEGY = new InjectionToken('_ViewRepeater');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ArrayDataSource, DataSource, SelectionModel, UniqueSelectionDispatcher, _DisposeViewRepeaterStrategy, _RecycleViewRepeaterStrategy, _VIEW_REPEATER_STRATEGY, getMultipleValuesInSingleSelectionError, isDataSource };\n","import { SPACE, BACKSPACE, DELETE, TAB, hasModifierKey, ENTER } from '@angular/cdk/keycodes';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Directive, EventEmitter, Optional, Inject, Attribute, ContentChild, Input, Output, Component, ViewEncapsulation, ChangeDetectionStrategy, Self, ContentChildren, NgModule } from '@angular/core';\nimport * as i3 from '@angular/material/core';\nimport { mixinTabIndex, mixinColor, mixinDisableRipple, RippleRenderer, MAT_RIPPLE_GLOBAL_OPTIONS, mixinErrorState, MatCommonModule, ErrorStateMatcher } from '@angular/material/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { DOCUMENT } from '@angular/common';\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\nimport { Subject, merge } from 'rxjs';\nimport { take, takeUntil, startWith } from 'rxjs/operators';\nimport * as i1 from '@angular/cdk/platform';\nimport { FocusKeyManager } from '@angular/cdk/a11y';\nimport { SelectionModel } from '@angular/cdk/collections';\nimport * as i2 from '@angular/forms';\nimport { Validators } from '@angular/forms';\nimport { MatFormFieldControl } from '@angular/material/form-field';\nimport * as i1$1 from '@angular/cdk/bidi';\n\n/** Event object emitted by MatChip when selected or deselected. */\nclass MatChipSelectionChange {\n    constructor(\n    /** Reference to the chip that emitted the event. */\n    source, \n    /** Whether the chip that emitted the event is selected. */\n    selected, \n    /** Whether the selection change was a result of a user interaction. */\n    isUserInput = false) {\n        this.source = source;\n        this.selected = selected;\n        this.isUserInput = isUserInput;\n    }\n}\n/**\n * Injection token that can be used to reference instances of `MatChipRemove`. It serves as\n * alternative token to the actual `MatChipRemove` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst MAT_CHIP_REMOVE = new InjectionToken('MatChipRemove');\n/**\n * Injection token that can be used to reference instances of `MatChipAvatar`. It serves as\n * alternative token to the actual `MatChipAvatar` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst MAT_CHIP_AVATAR = new InjectionToken('MatChipAvatar');\n/**\n * Injection token that can be used to reference instances of `MatChipTrailingIcon`. It serves as\n * alternative token to the actual `MatChipTrailingIcon` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst MAT_CHIP_TRAILING_ICON = new InjectionToken('MatChipTrailingIcon');\n// Boilerplate for applying mixins to MatChip.\n/** @docs-private */\nclass MatChipBase {\n    constructor(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n}\nconst _MatChipMixinBase = mixinTabIndex(mixinColor(mixinDisableRipple(MatChipBase), 'primary'), -1);\n/**\n * Dummy directive to add CSS class to chip avatar.\n * @docs-private\n */\nclass MatChipAvatar {\n}\nMatChipAvatar.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatChipAvatar, deps: [], target: i0.ɵɵFactoryTarget.Directive });\nMatChipAvatar.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.0\", type: MatChipAvatar, selector: \"mat-chip-avatar, [matChipAvatar]\", host: { classAttribute: \"mat-chip-avatar\" }, providers: [{ provide: MAT_CHIP_AVATAR, useExisting: MatChipAvatar }], ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatChipAvatar, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'mat-chip-avatar, [matChipAvatar]',\n                    host: { 'class': 'mat-chip-avatar' },\n                    providers: [{ provide: MAT_CHIP_AVATAR, useExisting: MatChipAvatar }],\n                }]\n        }] });\n/**\n * Dummy directive to add CSS class to chip trailing icon.\n * @docs-private\n */\nclass MatChipTrailingIcon {\n}\nMatChipTrailingIcon.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatChipTrailingIcon, deps: [], target: i0.ɵɵFactoryTarget.Directive });\nMatChipTrailingIcon.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.0\", type: MatChipTrailingIcon, selector: \"mat-chip-trailing-icon, [matChipTrailingIcon]\", host: { classAttribute: \"mat-chip-trailing-icon\" }, providers: [{ provide: MAT_CHIP_TRAILING_ICON, useExisting: MatChipTrailingIcon }], ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatChipTrailingIcon, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'mat-chip-trailing-icon, [matChipTrailingIcon]',\n                    host: { 'class': 'mat-chip-trailing-icon' },\n                    providers: [{ provide: MAT_CHIP_TRAILING_ICON, useExisting: MatChipTrailingIcon }],\n                }]\n        }] });\n/** Material Design styled chip directive. Used inside the MatChipList component. */\nclass MatChip extends _MatChipMixinBase {\n    constructor(elementRef, _ngZone, platform, globalRippleOptions, _changeDetectorRef, _document, animationMode, tabIndex) {\n        super(elementRef);\n        this._ngZone = _ngZone;\n        this._changeDetectorRef = _changeDetectorRef;\n        /** Whether the chip has focus. */\n        this._hasFocus = false;\n        /** Whether the chip list is selectable */\n        this.chipListSelectable = true;\n        /** Whether the chip list is in multi-selection mode. */\n        this._chipListMultiple = false;\n        /** Whether the chip list as a whole is disabled. */\n        this._chipListDisabled = false;\n        this._selected = false;\n        this._selectable = true;\n        this._disabled = false;\n        this._removable = true;\n        /** Emits when the chip is focused. */\n        this._onFocus = new Subject();\n        /** Emits when the chip is blured. */\n        this._onBlur = new Subject();\n        /** Emitted when the chip is selected or deselected. */\n        this.selectionChange = new EventEmitter();\n        /** Emitted when the chip is destroyed. */\n        this.destroyed = new EventEmitter();\n        /** Emitted when a chip is to be removed. */\n        this.removed = new EventEmitter();\n        this._addHostClassName();\n        // Dynamically create the ripple target, append it within the chip, and use it as the\n        // chip's ripple target. Adding the class '.mat-chip-ripple' ensures that it will have\n        // the proper styles.\n        this._chipRippleTarget = _document.createElement('div');\n        this._chipRippleTarget.classList.add('mat-chip-ripple');\n        this._elementRef.nativeElement.appendChild(this._chipRippleTarget);\n        this._chipRipple = new RippleRenderer(this, _ngZone, this._chipRippleTarget, platform);\n        this._chipRipple.setupTriggerEvents(elementRef);\n        this.rippleConfig = globalRippleOptions || {};\n        this._animationsDisabled = animationMode === 'NoopAnimations';\n        this.tabIndex = tabIndex != null ? parseInt(tabIndex) || -1 : -1;\n    }\n    /**\n     * Whether ripples are disabled on interaction\n     * @docs-private\n     */\n    get rippleDisabled() {\n        return (this.disabled ||\n            this.disableRipple ||\n            this._animationsDisabled ||\n            !!this.rippleConfig.disabled);\n    }\n    /** Whether the chip is selected. */\n    get selected() {\n        return this._selected;\n    }\n    set selected(value) {\n        const coercedValue = coerceBooleanProperty(value);\n        if (coercedValue !== this._selected) {\n            this._selected = coercedValue;\n            this._dispatchSelectionChange();\n        }\n    }\n    /** The value of the chip. Defaults to the content inside `<mat-chip>` tags. */\n    get value() {\n        return this._value !== undefined ? this._value : this._elementRef.nativeElement.textContent;\n    }\n    set value(value) {\n        this._value = value;\n    }\n    /**\n     * Whether or not the chip is selectable. When a chip is not selectable,\n     * changes to its selected state are always ignored. By default a chip is\n     * selectable, and it becomes non-selectable if its parent chip list is\n     * not selectable.\n     */\n    get selectable() {\n        return this._selectable && this.chipListSelectable;\n    }\n    set selectable(value) {\n        this._selectable = coerceBooleanProperty(value);\n    }\n    /** Whether the chip is disabled. */\n    get disabled() {\n        return this._chipListDisabled || this._disabled;\n    }\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n    }\n    /**\n     * Determines whether or not the chip displays the remove styling and emits (removed) events.\n     */\n    get removable() {\n        return this._removable;\n    }\n    set removable(value) {\n        this._removable = coerceBooleanProperty(value);\n    }\n    /** The ARIA selected applied to the chip. */\n    get ariaSelected() {\n        // Remove the `aria-selected` when the chip is deselected in single-selection mode, because\n        // it adds noise to NVDA users where \"not selected\" will be read out for each chip.\n        return this.selectable && (this._chipListMultiple || this.selected)\n            ? this.selected.toString()\n            : null;\n    }\n    _addHostClassName() {\n        const basicChipAttrName = 'mat-basic-chip';\n        const element = this._elementRef.nativeElement;\n        if (element.hasAttribute(basicChipAttrName) ||\n            element.tagName.toLowerCase() === basicChipAttrName) {\n            element.classList.add(basicChipAttrName);\n            return;\n        }\n        else {\n            element.classList.add('mat-standard-chip');\n        }\n    }\n    ngOnDestroy() {\n        this.destroyed.emit({ chip: this });\n        this._chipRipple._removeTriggerEvents();\n    }\n    /** Selects the chip. */\n    select() {\n        if (!this._selected) {\n            this._selected = true;\n            this._dispatchSelectionChange();\n            this._changeDetectorRef.markForCheck();\n        }\n    }\n    /** Deselects the chip. */\n    deselect() {\n        if (this._selected) {\n            this._selected = false;\n            this._dispatchSelectionChange();\n            this._changeDetectorRef.markForCheck();\n        }\n    }\n    /** Select this chip and emit selected event */\n    selectViaInteraction() {\n        if (!this._selected) {\n            this._selected = true;\n            this._dispatchSelectionChange(true);\n            this._changeDetectorRef.markForCheck();\n        }\n    }\n    /** Toggles the current selected state of this chip. */\n    toggleSelected(isUserInput = false) {\n        this._selected = !this.selected;\n        this._dispatchSelectionChange(isUserInput);\n        this._changeDetectorRef.markForCheck();\n        return this.selected;\n    }\n    /** Allows for programmatic focusing of the chip. */\n    focus() {\n        if (!this._hasFocus) {\n            this._elementRef.nativeElement.focus();\n            this._onFocus.next({ chip: this });\n        }\n        this._hasFocus = true;\n    }\n    /**\n     * Allows for programmatic removal of the chip. Called by the MatChipList when the DELETE or\n     * BACKSPACE keys are pressed.\n     *\n     * Informs any listeners of the removal request. Does not remove the chip from the DOM.\n     */\n    remove() {\n        if (this.removable) {\n            this.removed.emit({ chip: this });\n        }\n    }\n    /** Handles click events on the chip. */\n    _handleClick(event) {\n        if (this.disabled) {\n            event.preventDefault();\n        }\n    }\n    /** Handle custom key presses. */\n    _handleKeydown(event) {\n        if (this.disabled) {\n            return;\n        }\n        switch (event.keyCode) {\n            case DELETE:\n            case BACKSPACE:\n                // If we are removable, remove the focused chip\n                this.remove();\n                // Always prevent so page navigation does not occur\n                event.preventDefault();\n                break;\n            case SPACE:\n                // If we are selectable, toggle the focused chip\n                if (this.selectable) {\n                    this.toggleSelected(true);\n                }\n                // Always prevent space from scrolling the page since the list has focus\n                event.preventDefault();\n                break;\n        }\n    }\n    _blur() {\n        // When animations are enabled, Angular may end up removing the chip from the DOM a little\n        // earlier than usual, causing it to be blurred and throwing off the logic in the chip list\n        // that moves focus not the next item. To work around the issue, we defer marking the chip\n        // as not focused until the next time the zone stabilizes.\n        this._ngZone.onStable.pipe(take(1)).subscribe(() => {\n            this._ngZone.run(() => {\n                this._hasFocus = false;\n                this._onBlur.next({ chip: this });\n            });\n        });\n    }\n    _dispatchSelectionChange(isUserInput = false) {\n        this.selectionChange.emit({\n            source: this,\n            isUserInput,\n            selected: this._selected,\n        });\n    }\n}\nMatChip.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatChip, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }, { token: i1.Platform }, { token: MAT_RIPPLE_GLOBAL_OPTIONS, optional: true }, { token: i0.ChangeDetectorRef }, { token: DOCUMENT }, { token: ANIMATION_MODULE_TYPE, optional: true }, { token: 'tabindex', attribute: true }], target: i0.ɵɵFactoryTarget.Directive });\nMatChip.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.0\", type: MatChip, selector: \"mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]\", inputs: { color: \"color\", disableRipple: \"disableRipple\", tabIndex: \"tabIndex\", selected: \"selected\", value: \"value\", selectable: \"selectable\", disabled: \"disabled\", removable: \"removable\" }, outputs: { selectionChange: \"selectionChange\", destroyed: \"destroyed\", removed: \"removed\" }, host: { attributes: { \"role\": \"option\" }, listeners: { \"click\": \"_handleClick($event)\", \"keydown\": \"_handleKeydown($event)\", \"focus\": \"focus()\", \"blur\": \"_blur()\" }, properties: { \"attr.tabindex\": \"disabled ? null : tabIndex\", \"class.mat-chip-selected\": \"selected\", \"class.mat-chip-with-avatar\": \"avatar\", \"class.mat-chip-with-trailing-icon\": \"trailingIcon || removeIcon\", \"class.mat-chip-disabled\": \"disabled\", \"class._mat-animation-noopable\": \"_animationsDisabled\", \"attr.disabled\": \"disabled || null\", \"attr.aria-disabled\": \"disabled.toString()\", \"attr.aria-selected\": \"ariaSelected\" }, classAttribute: \"mat-chip mat-focus-indicator\" }, queries: [{ propertyName: \"avatar\", first: true, predicate: MAT_CHIP_AVATAR, descendants: true }, { propertyName: \"trailingIcon\", first: true, predicate: MAT_CHIP_TRAILING_ICON, descendants: true }, { propertyName: \"removeIcon\", first: true, predicate: MAT_CHIP_REMOVE, descendants: true }], exportAs: [\"matChip\"], usesInheritance: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatChip, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: `mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]`,\n                    inputs: ['color', 'disableRipple', 'tabIndex'],\n                    exportAs: 'matChip',\n                    host: {\n                        'class': 'mat-chip mat-focus-indicator',\n                        '[attr.tabindex]': 'disabled ? null : tabIndex',\n                        'role': 'option',\n                        '[class.mat-chip-selected]': 'selected',\n                        '[class.mat-chip-with-avatar]': 'avatar',\n                        '[class.mat-chip-with-trailing-icon]': 'trailingIcon || removeIcon',\n                        '[class.mat-chip-disabled]': 'disabled',\n                        '[class._mat-animation-noopable]': '_animationsDisabled',\n                        '[attr.disabled]': 'disabled || null',\n                        '[attr.aria-disabled]': 'disabled.toString()',\n                        '[attr.aria-selected]': 'ariaSelected',\n                        '(click)': '_handleClick($event)',\n                        '(keydown)': '_handleKeydown($event)',\n                        '(focus)': 'focus()',\n                        '(blur)': '_blur()',\n                    },\n                }]\n        }], ctorParameters: function () {\n        return [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: i1.Platform }, { type: undefined, decorators: [{\n                        type: Optional\n                    }, {\n                        type: Inject,\n                        args: [MAT_RIPPLE_GLOBAL_OPTIONS]\n                    }] }, { type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{\n                        type: Inject,\n                        args: [DOCUMENT]\n                    }] }, { type: undefined, decorators: [{\n                        type: Optional\n                    }, {\n                        type: Inject,\n                        args: [ANIMATION_MODULE_TYPE]\n                    }] }, { type: undefined, decorators: [{\n                        type: Attribute,\n                        args: ['tabindex']\n                    }] }];\n    }, propDecorators: { avatar: [{\n                type: ContentChild,\n                args: [MAT_CHIP_AVATAR]\n            }], trailingIcon: [{\n                type: ContentChild,\n                args: [MAT_CHIP_TRAILING_ICON]\n            }], removeIcon: [{\n                type: ContentChild,\n                args: [MAT_CHIP_REMOVE]\n            }], selected: [{\n                type: Input\n            }], value: [{\n                type: Input\n            }], selectable: [{\n                type: Input\n            }], disabled: [{\n                type: Input\n            }], removable: [{\n                type: Input\n            }], selectionChange: [{\n                type: Output\n            }], destroyed: [{\n                type: Output\n            }], removed: [{\n                type: Output\n            }] } });\n/**\n * Applies proper (click) support and adds styling for use with the Material Design \"cancel\" icon\n * available at https://material.io/icons/#ic_cancel.\n *\n * Example:\n *\n *     `<mat-chip>\n *       <mat-icon matChipRemove>cancel</mat-icon>\n *     </mat-chip>`\n *\n * You *may* use a custom icon, but you may need to override the `mat-chip-remove` positioning\n * styles to properly center the icon within the chip.\n */\nclass MatChipRemove {\n    constructor(_parentChip, elementRef) {\n        this._parentChip = _parentChip;\n        if (elementRef.nativeElement.nodeName === 'BUTTON') {\n            elementRef.nativeElement.setAttribute('type', 'button');\n        }\n    }\n    /** Calls the parent chip's public `remove()` method if applicable. */\n    _handleClick(event) {\n        const parentChip = this._parentChip;\n        if (parentChip.removable && !parentChip.disabled) {\n            parentChip.remove();\n        }\n        // We need to stop event propagation because otherwise the event will bubble up to the\n        // form field and cause the `onContainerClick` method to be invoked. This method would then\n        // reset the focused chip that has been focused after chip removal. Usually the parent\n        // the parent click listener of the `MatChip` would prevent propagation, but it can happen\n        // that the chip is being removed before the event bubbles up.\n        event.stopPropagation();\n        event.preventDefault();\n    }\n}\nMatChipRemove.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatChipRemove, deps: [{ token: MatChip }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });\nMatChipRemove.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.0\", type: MatChipRemove, selector: \"[matChipRemove]\", host: { listeners: { \"click\": \"_handleClick($event)\" }, classAttribute: \"mat-chip-remove mat-chip-trailing-icon\" }, providers: [{ provide: MAT_CHIP_REMOVE, useExisting: MatChipRemove }], ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatChipRemove, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[matChipRemove]',\n                    host: {\n                        'class': 'mat-chip-remove mat-chip-trailing-icon',\n                        '(click)': '_handleClick($event)',\n                    },\n                    providers: [{ provide: MAT_CHIP_REMOVE, useExisting: MatChipRemove }],\n                }]\n        }], ctorParameters: function () { return [{ type: MatChip }, { type: i0.ElementRef }]; } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Injection token to be used to override the default options for the chips module. */\nconst MAT_CHIPS_DEFAULT_OPTIONS = new InjectionToken('mat-chips-default-options');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Increasing integer for generating unique ids.\nlet nextUniqueId$1 = 0;\n/**\n * Directive that adds chip-specific behaviors to an input element inside `<mat-form-field>`.\n * May be placed inside or outside of an `<mat-chip-list>`.\n */\nclass MatChipInput {\n    constructor(_elementRef, _defaultOptions) {\n        this._elementRef = _elementRef;\n        this._defaultOptions = _defaultOptions;\n        /** Whether the control is focused. */\n        this.focused = false;\n        this._addOnBlur = false;\n        /**\n         * The list of key codes that will trigger a chipEnd event.\n         *\n         * Defaults to `[ENTER]`.\n         */\n        this.separatorKeyCodes = this._defaultOptions.separatorKeyCodes;\n        /** Emitted when a chip is to be added. */\n        this.chipEnd = new EventEmitter();\n        /** The input's placeholder text. */\n        this.placeholder = '';\n        /** Unique id for the input. */\n        this.id = `mat-chip-list-input-${nextUniqueId$1++}`;\n        this._disabled = false;\n        this.inputElement = this._elementRef.nativeElement;\n    }\n    /** Register input for chip list */\n    set chipList(value) {\n        if (value) {\n            this._chipList = value;\n            this._chipList.registerInput(this);\n        }\n    }\n    /**\n     * Whether or not the chipEnd event will be emitted when the input is blurred.\n     */\n    get addOnBlur() {\n        return this._addOnBlur;\n    }\n    set addOnBlur(value) {\n        this._addOnBlur = coerceBooleanProperty(value);\n    }\n    /** Whether the input is disabled. */\n    get disabled() {\n        return this._disabled || (this._chipList && this._chipList.disabled);\n    }\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n    }\n    /** Whether the input is empty. */\n    get empty() {\n        return !this.inputElement.value;\n    }\n    ngOnChanges() {\n        this._chipList.stateChanges.next();\n    }\n    ngOnDestroy() {\n        this.chipEnd.complete();\n    }\n    ngAfterContentInit() {\n        this._focusLastChipOnBackspace = this.empty;\n    }\n    /** Utility method to make host definition/tests more clear. */\n    _keydown(event) {\n        if (event) {\n            // Allow the user's focus to escape when they're tabbing forward. Note that we don't\n            // want to do this when going backwards, because focus should go back to the first chip.\n            if (event.keyCode === TAB && !hasModifierKey(event, 'shiftKey')) {\n                this._chipList._allowFocusEscape();\n            }\n            // To prevent the user from accidentally deleting chips when pressing BACKSPACE continuously,\n            // We focus the last chip on backspace only after the user has released the backspace button,\n            // and the input is empty (see behaviour in _keyup)\n            if (event.keyCode === BACKSPACE && this._focusLastChipOnBackspace) {\n                this._chipList._keyManager.setLastItemActive();\n                event.preventDefault();\n                return;\n            }\n            else {\n                this._focusLastChipOnBackspace = false;\n            }\n        }\n        this._emitChipEnd(event);\n    }\n    /**\n     * Pass events to the keyboard manager. Available here for tests.\n     */\n    _keyup(event) {\n        // Allow user to move focus to chips next time he presses backspace\n        if (!this._focusLastChipOnBackspace && event.keyCode === BACKSPACE && this.empty) {\n            this._focusLastChipOnBackspace = true;\n            event.preventDefault();\n        }\n    }\n    /** Checks to see if the blur should emit the (chipEnd) event. */\n    _blur() {\n        if (this.addOnBlur) {\n            this._emitChipEnd();\n        }\n        this.focused = false;\n        // Blur the chip list if it is not focused\n        if (!this._chipList.focused) {\n            this._chipList._blur();\n        }\n        this._chipList.stateChanges.next();\n    }\n    _focus() {\n        this.focused = true;\n        this._focusLastChipOnBackspace = this.empty;\n        this._chipList.stateChanges.next();\n    }\n    /** Checks to see if the (chipEnd) event needs to be emitted. */\n    _emitChipEnd(event) {\n        if (!this.inputElement.value && !!event) {\n            this._chipList._keydown(event);\n        }\n        if (!event || this._isSeparatorKey(event)) {\n            this.chipEnd.emit({\n                input: this.inputElement,\n                value: this.inputElement.value,\n                chipInput: this,\n            });\n            event === null || event === void 0 ? void 0 : event.preventDefault();\n        }\n    }\n    _onInput() {\n        // Let chip list know whenever the value changes.\n        this._chipList.stateChanges.next();\n    }\n    /** Focuses the input. */\n    focus(options) {\n        this.inputElement.focus(options);\n    }\n    /** Clears the input */\n    clear() {\n        this.inputElement.value = '';\n        this._focusLastChipOnBackspace = true;\n    }\n    /** Checks whether a keycode is one of the configured separators. */\n    _isSeparatorKey(event) {\n        return !hasModifierKey(event) && new Set(this.separatorKeyCodes).has(event.keyCode);\n    }\n}\nMatChipInput.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatChipInput, deps: [{ token: i0.ElementRef }, { token: MAT_CHIPS_DEFAULT_OPTIONS }], target: i0.ɵɵFactoryTarget.Directive });\nMatChipInput.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.0\", type: MatChipInput, selector: \"input[matChipInputFor]\", inputs: { chipList: [\"matChipInputFor\", \"chipList\"], addOnBlur: [\"matChipInputAddOnBlur\", \"addOnBlur\"], separatorKeyCodes: [\"matChipInputSeparatorKeyCodes\", \"separatorKeyCodes\"], placeholder: \"placeholder\", id: \"id\", disabled: \"disabled\" }, outputs: { chipEnd: \"matChipInputTokenEnd\" }, host: { listeners: { \"keydown\": \"_keydown($event)\", \"keyup\": \"_keyup($event)\", \"blur\": \"_blur()\", \"focus\": \"_focus()\", \"input\": \"_onInput()\" }, properties: { \"id\": \"id\", \"attr.disabled\": \"disabled || null\", \"attr.placeholder\": \"placeholder || null\", \"attr.aria-invalid\": \"_chipList && _chipList.ngControl ? _chipList.ngControl.invalid : null\", \"attr.aria-required\": \"_chipList && _chipList.required || null\" }, classAttribute: \"mat-chip-input mat-input-element\" }, exportAs: [\"matChipInput\", \"matChipInputFor\"], usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatChipInput, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'input[matChipInputFor]',\n                    exportAs: 'matChipInput, matChipInputFor',\n                    host: {\n                        'class': 'mat-chip-input mat-input-element',\n                        '(keydown)': '_keydown($event)',\n                        '(keyup)': '_keyup($event)',\n                        '(blur)': '_blur()',\n                        '(focus)': '_focus()',\n                        '(input)': '_onInput()',\n                        '[id]': 'id',\n                        '[attr.disabled]': 'disabled || null',\n                        '[attr.placeholder]': 'placeholder || null',\n                        '[attr.aria-invalid]': '_chipList && _chipList.ngControl ? _chipList.ngControl.invalid : null',\n                        '[attr.aria-required]': '_chipList && _chipList.required || null',\n                    },\n                }]\n        }], ctorParameters: function () {\n        return [{ type: i0.ElementRef }, { type: undefined, decorators: [{\n                        type: Inject,\n                        args: [MAT_CHIPS_DEFAULT_OPTIONS]\n                    }] }];\n    }, propDecorators: { chipList: [{\n                type: Input,\n                args: ['matChipInputFor']\n            }], addOnBlur: [{\n                type: Input,\n                args: ['matChipInputAddOnBlur']\n            }], separatorKeyCodes: [{\n                type: Input,\n                args: ['matChipInputSeparatorKeyCodes']\n            }], chipEnd: [{\n                type: Output,\n                args: ['matChipInputTokenEnd']\n            }], placeholder: [{\n                type: Input\n            }], id: [{\n                type: Input\n            }], disabled: [{\n                type: Input\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Boilerplate for applying mixins to MatChipList.\n/** @docs-private */\nconst _MatChipListBase = mixinErrorState(class {\n    constructor(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, \n    /** @docs-private */\n    ngControl) {\n        this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n        this._parentForm = _parentForm;\n        this._parentFormGroup = _parentFormGroup;\n        this.ngControl = ngControl;\n    }\n});\n// Increasing integer for generating unique ids for chip-list components.\nlet nextUniqueId = 0;\n/** Change event object that is emitted when the chip list value has changed. */\nclass MatChipListChange {\n    constructor(\n    /** Chip list that emitted the event. */\n    source, \n    /** Value of the chip list when the event was emitted. */\n    value) {\n        this.source = source;\n        this.value = value;\n    }\n}\n/**\n * A material design chips component (named ChipList for its similarity to the List component).\n */\nclass MatChipList extends _MatChipListBase {\n    constructor(_elementRef, _changeDetectorRef, _dir, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, ngControl) {\n        super(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n        this._elementRef = _elementRef;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._dir = _dir;\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        this.controlType = 'mat-chip-list';\n        /**\n         * When a chip is destroyed, we store the index of the destroyed chip until the chips\n         * query list notifies about the update. This is necessary because we cannot determine an\n         * appropriate chip that should receive focus until the array of chips updated completely.\n         */\n        this._lastDestroyedChipIndex = null;\n        /** Subject that emits when the component has been destroyed. */\n        this._destroyed = new Subject();\n        /** Uid of the chip list */\n        this._uid = `mat-chip-list-${nextUniqueId++}`;\n        /** Tab index for the chip list. */\n        this._tabIndex = 0;\n        /**\n         * User defined tab index.\n         * When it is not null, use user defined tab index. Otherwise use _tabIndex\n         */\n        this._userTabIndex = null;\n        /** Function when touched */\n        this._onTouched = () => { };\n        /** Function when changed */\n        this._onChange = () => { };\n        this._multiple = false;\n        this._compareWith = (o1, o2) => o1 === o2;\n        this._disabled = false;\n        /** Orientation of the chip list. */\n        this.ariaOrientation = 'horizontal';\n        this._selectable = true;\n        /** Event emitted when the selected chip list value has been changed by the user. */\n        this.change = new EventEmitter();\n        /**\n         * Event that emits whenever the raw value of the chip-list changes. This is here primarily\n         * to facilitate the two-way binding for the `value` input.\n         * @docs-private\n         */\n        this.valueChange = new EventEmitter();\n        if (this.ngControl) {\n            this.ngControl.valueAccessor = this;\n        }\n    }\n    /** The array of selected chips inside chip list. */\n    get selected() {\n        var _a, _b;\n        return this.multiple ? ((_a = this._selectionModel) === null || _a === void 0 ? void 0 : _a.selected) || [] : (_b = this._selectionModel) === null || _b === void 0 ? void 0 : _b.selected[0];\n    }\n    /** The ARIA role applied to the chip list. */\n    get role() {\n        return this.empty ? null : 'listbox';\n    }\n    /** Whether the user should be allowed to select multiple chips. */\n    get multiple() {\n        return this._multiple;\n    }\n    set multiple(value) {\n        this._multiple = coerceBooleanProperty(value);\n        this._syncChipsState();\n    }\n    /**\n     * A function to compare the option values with the selected values. The first argument\n     * is a value from an option. The second is a value from the selection. A boolean\n     * should be returned.\n     */\n    get compareWith() {\n        return this._compareWith;\n    }\n    set compareWith(fn) {\n        this._compareWith = fn;\n        if (this._selectionModel) {\n            // A different comparator means the selection could change.\n            this._initializeSelection();\n        }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get value() {\n        return this._value;\n    }\n    set value(value) {\n        this.writeValue(value);\n        this._value = value;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get id() {\n        return this._chipInput ? this._chipInput.id : this._uid;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get required() {\n        var _a, _b, _c, _d;\n        return (_d = (_a = this._required) !== null && _a !== void 0 ? _a : (_c = (_b = this.ngControl) === null || _b === void 0 ? void 0 : _b.control) === null || _c === void 0 ? void 0 : _c.hasValidator(Validators.required)) !== null && _d !== void 0 ? _d : false;\n    }\n    set required(value) {\n        this._required = coerceBooleanProperty(value);\n        this.stateChanges.next();\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get placeholder() {\n        return this._chipInput ? this._chipInput.placeholder : this._placeholder;\n    }\n    set placeholder(value) {\n        this._placeholder = value;\n        this.stateChanges.next();\n    }\n    /** Whether any chips or the matChipInput inside of this chip-list has focus. */\n    get focused() {\n        return (this._chipInput && this._chipInput.focused) || this._hasFocusedChip();\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get empty() {\n        return (!this._chipInput || this._chipInput.empty) && (!this.chips || this.chips.length === 0);\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get shouldLabelFloat() {\n        return !this.empty || this.focused;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get disabled() {\n        return this.ngControl ? !!this.ngControl.disabled : this._disabled;\n    }\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n        this._syncChipsState();\n    }\n    /**\n     * Whether or not this chip list is selectable. When a chip list is not selectable,\n     * the selected states for all the chips inside the chip list are always ignored.\n     */\n    get selectable() {\n        return this._selectable;\n    }\n    set selectable(value) {\n        this._selectable = coerceBooleanProperty(value);\n        if (this.chips) {\n            this.chips.forEach(chip => (chip.chipListSelectable = this._selectable));\n        }\n    }\n    set tabIndex(value) {\n        this._userTabIndex = value;\n        this._tabIndex = value;\n    }\n    /** Combined stream of all of the child chips' selection change events. */\n    get chipSelectionChanges() {\n        return merge(...this.chips.map(chip => chip.selectionChange));\n    }\n    /** Combined stream of all of the child chips' focus change events. */\n    get chipFocusChanges() {\n        return merge(...this.chips.map(chip => chip._onFocus));\n    }\n    /** Combined stream of all of the child chips' blur change events. */\n    get chipBlurChanges() {\n        return merge(...this.chips.map(chip => chip._onBlur));\n    }\n    /** Combined stream of all of the child chips' remove change events. */\n    get chipRemoveChanges() {\n        return merge(...this.chips.map(chip => chip.destroyed));\n    }\n    ngAfterContentInit() {\n        this._keyManager = new FocusKeyManager(this.chips)\n            .withWrap()\n            .withVerticalOrientation()\n            .withHomeAndEnd()\n            .withHorizontalOrientation(this._dir ? this._dir.value : 'ltr');\n        if (this._dir) {\n            this._dir.change\n                .pipe(takeUntil(this._destroyed))\n                .subscribe(dir => this._keyManager.withHorizontalOrientation(dir));\n        }\n        this._keyManager.tabOut.pipe(takeUntil(this._destroyed)).subscribe(() => {\n            this._allowFocusEscape();\n        });\n        // When the list changes, re-subscribe\n        this.chips.changes.pipe(startWith(null), takeUntil(this._destroyed)).subscribe(() => {\n            if (this.disabled) {\n                // Since this happens after the content has been\n                // checked, we need to defer it to the next tick.\n                Promise.resolve().then(() => {\n                    this._syncChipsState();\n                });\n            }\n            this._resetChips();\n            // Reset chips selected/deselected status\n            this._initializeSelection();\n            // Check to see if we need to update our tab index\n            this._updateTabIndex();\n            // Check to see if we have a destroyed chip and need to refocus\n            this._updateFocusForDestroyedChips();\n            this.stateChanges.next();\n        });\n    }\n    ngOnInit() {\n        this._selectionModel = new SelectionModel(this.multiple, undefined, false);\n        this.stateChanges.next();\n    }\n    ngDoCheck() {\n        if (this.ngControl) {\n            // We need to re-evaluate this on every change detection cycle, because there are some\n            // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n            // that whatever logic is in here has to be super lean or we risk destroying the performance.\n            this.updateErrorState();\n            if (this.ngControl.disabled !== this._disabled) {\n                this.disabled = !!this.ngControl.disabled;\n            }\n        }\n    }\n    ngOnDestroy() {\n        this._destroyed.next();\n        this._destroyed.complete();\n        this.stateChanges.complete();\n        this._dropSubscriptions();\n    }\n    /** Associates an HTML input element with this chip list. */\n    registerInput(inputElement) {\n        this._chipInput = inputElement;\n        // We use this attribute to match the chip list to its input in test harnesses.\n        // Set the attribute directly here to avoid \"changed after checked\" errors.\n        this._elementRef.nativeElement.setAttribute('data-mat-chip-input', inputElement.id);\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    setDescribedByIds(ids) {\n        this._ariaDescribedby = ids.join(' ');\n    }\n    // Implemented as part of ControlValueAccessor.\n    writeValue(value) {\n        if (this.chips) {\n            this._setSelectionByValue(value, false);\n        }\n    }\n    // Implemented as part of ControlValueAccessor.\n    registerOnChange(fn) {\n        this._onChange = fn;\n    }\n    // Implemented as part of ControlValueAccessor.\n    registerOnTouched(fn) {\n        this._onTouched = fn;\n    }\n    // Implemented as part of ControlValueAccessor.\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n        this.stateChanges.next();\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    onContainerClick(event) {\n        if (!this._originatesFromChip(event)) {\n            this.focus();\n        }\n    }\n    /**\n     * Focuses the first non-disabled chip in this chip list, or the associated input when there\n     * are no eligible chips.\n     */\n    focus(options) {\n        if (this.disabled) {\n            return;\n        }\n        // TODO: ARIA says this should focus the first `selected` chip if any are selected.\n        // Focus on first element if there's no chipInput inside chip-list\n        if (this._chipInput && this._chipInput.focused) {\n            // do nothing\n        }\n        else if (this.chips.length > 0) {\n            this._keyManager.setFirstItemActive();\n            this.stateChanges.next();\n        }\n        else {\n            this._focusInput(options);\n            this.stateChanges.next();\n        }\n    }\n    /** Attempt to focus an input if we have one. */\n    _focusInput(options) {\n        if (this._chipInput) {\n            this._chipInput.focus(options);\n        }\n    }\n    /**\n     * Pass events to the keyboard manager. Available here for tests.\n     */\n    _keydown(event) {\n        const target = event.target;\n        if (target && target.classList.contains('mat-chip')) {\n            this._keyManager.onKeydown(event);\n            this.stateChanges.next();\n        }\n    }\n    /**\n     * Check the tab index as you should not be allowed to focus an empty list.\n     */\n    _updateTabIndex() {\n        // If we have 0 chips, we should not allow keyboard focus\n        this._tabIndex = this._userTabIndex || (this.chips.length === 0 ? -1 : 0);\n    }\n    /**\n     * If the amount of chips changed, we need to update the\n     * key manager state and focus the next closest chip.\n     */\n    _updateFocusForDestroyedChips() {\n        // Move focus to the closest chip. If no other chips remain, focus the chip-list itself.\n        if (this._lastDestroyedChipIndex != null) {\n            if (this.chips.length) {\n                const newChipIndex = Math.min(this._lastDestroyedChipIndex, this.chips.length - 1);\n                this._keyManager.setActiveItem(newChipIndex);\n            }\n            else {\n                this.focus();\n            }\n        }\n        this._lastDestroyedChipIndex = null;\n    }\n    /**\n     * Utility to ensure all indexes are valid.\n     *\n     * @param index The index to be checked.\n     * @returns True if the index is valid for our list of chips.\n     */\n    _isValidIndex(index) {\n        return index >= 0 && index < this.chips.length;\n    }\n    _setSelectionByValue(value, isUserInput = true) {\n        this._clearSelection();\n        this.chips.forEach(chip => chip.deselect());\n        if (Array.isArray(value)) {\n            value.forEach(currentValue => this._selectValue(currentValue, isUserInput));\n            this._sortValues();\n        }\n        else {\n            const correspondingChip = this._selectValue(value, isUserInput);\n            // Shift focus to the active item. Note that we shouldn't do this in multiple\n            // mode, because we don't know what chip the user interacted with last.\n            if (correspondingChip) {\n                if (isUserInput) {\n                    this._keyManager.setActiveItem(correspondingChip);\n                }\n            }\n        }\n    }\n    /**\n     * Finds and selects the chip based on its value.\n     * @returns Chip that has the corresponding value.\n     */\n    _selectValue(value, isUserInput = true) {\n        const correspondingChip = this.chips.find(chip => {\n            return chip.value != null && this._compareWith(chip.value, value);\n        });\n        if (correspondingChip) {\n            isUserInput ? correspondingChip.selectViaInteraction() : correspondingChip.select();\n            this._selectionModel.select(correspondingChip);\n        }\n        return correspondingChip;\n    }\n    _initializeSelection() {\n        // Defer setting the value in order to avoid the \"Expression\n        // has changed after it was checked\" errors from Angular.\n        Promise.resolve().then(() => {\n            if (this.ngControl || this._value) {\n                this._setSelectionByValue(this.ngControl ? this.ngControl.value : this._value, false);\n                this.stateChanges.next();\n            }\n        });\n    }\n    /**\n     * Deselects every chip in the list.\n     * @param skip Chip that should not be deselected.\n     */\n    _clearSelection(skip) {\n        this._selectionModel.clear();\n        this.chips.forEach(chip => {\n            if (chip !== skip) {\n                chip.deselect();\n            }\n        });\n        this.stateChanges.next();\n    }\n    /**\n     * Sorts the model values, ensuring that they keep the same\n     * order that they have in the panel.\n     */\n    _sortValues() {\n        if (this._multiple) {\n            this._selectionModel.clear();\n            this.chips.forEach(chip => {\n                if (chip.selected) {\n                    this._selectionModel.select(chip);\n                }\n            });\n            this.stateChanges.next();\n        }\n    }\n    /** Emits change event to set the model value. */\n    _propagateChanges(fallbackValue) {\n        let valueToEmit = null;\n        if (Array.isArray(this.selected)) {\n            valueToEmit = this.selected.map(chip => chip.value);\n        }\n        else {\n            valueToEmit = this.selected ? this.selected.value : fallbackValue;\n        }\n        this._value = valueToEmit;\n        this.change.emit(new MatChipListChange(this, valueToEmit));\n        this.valueChange.emit(valueToEmit);\n        this._onChange(valueToEmit);\n        this._changeDetectorRef.markForCheck();\n    }\n    /** When blurred, mark the field as touched when focus moved outside the chip list. */\n    _blur() {\n        if (!this._hasFocusedChip()) {\n            this._keyManager.setActiveItem(-1);\n        }\n        if (!this.disabled) {\n            if (this._chipInput) {\n                // If there's a chip input, we should check whether the focus moved to chip input.\n                // If the focus is not moved to chip input, mark the field as touched. If the focus moved\n                // to chip input, do nothing.\n                // Timeout is needed to wait for the focus() event trigger on chip input.\n                setTimeout(() => {\n                    if (!this.focused) {\n                        this._markAsTouched();\n                    }\n                });\n            }\n            else {\n                // If there's no chip input, then mark the field as touched.\n                this._markAsTouched();\n            }\n        }\n    }\n    /** Mark the field as touched */\n    _markAsTouched() {\n        this._onTouched();\n        this._changeDetectorRef.markForCheck();\n        this.stateChanges.next();\n    }\n    /**\n     * Removes the `tabindex` from the chip list and resets it back afterwards, allowing the\n     * user to tab out of it. This prevents the list from capturing focus and redirecting\n     * it back to the first chip, creating a focus trap, if it user tries to tab away.\n     */\n    _allowFocusEscape() {\n        if (this._tabIndex !== -1) {\n            this._tabIndex = -1;\n            setTimeout(() => {\n                this._tabIndex = this._userTabIndex || 0;\n                this._changeDetectorRef.markForCheck();\n            });\n        }\n    }\n    _resetChips() {\n        this._dropSubscriptions();\n        this._listenToChipsFocus();\n        this._listenToChipsSelection();\n        this._listenToChipsRemoved();\n    }\n    _dropSubscriptions() {\n        if (this._chipFocusSubscription) {\n            this._chipFocusSubscription.unsubscribe();\n            this._chipFocusSubscription = null;\n        }\n        if (this._chipBlurSubscription) {\n            this._chipBlurSubscription.unsubscribe();\n            this._chipBlurSubscription = null;\n        }\n        if (this._chipSelectionSubscription) {\n            this._chipSelectionSubscription.unsubscribe();\n            this._chipSelectionSubscription = null;\n        }\n        if (this._chipRemoveSubscription) {\n            this._chipRemoveSubscription.unsubscribe();\n            this._chipRemoveSubscription = null;\n        }\n    }\n    /** Listens to user-generated selection events on each chip. */\n    _listenToChipsSelection() {\n        this._chipSelectionSubscription = this.chipSelectionChanges.subscribe(event => {\n            event.source.selected\n                ? this._selectionModel.select(event.source)\n                : this._selectionModel.deselect(event.source);\n            // For single selection chip list, make sure the deselected value is unselected.\n            if (!this.multiple) {\n                this.chips.forEach(chip => {\n                    if (!this._selectionModel.isSelected(chip) && chip.selected) {\n                        chip.deselect();\n                    }\n                });\n            }\n            if (event.isUserInput) {\n                this._propagateChanges();\n            }\n        });\n    }\n    /** Listens to user-generated selection events on each chip. */\n    _listenToChipsFocus() {\n        this._chipFocusSubscription = this.chipFocusChanges.subscribe(event => {\n            let chipIndex = this.chips.toArray().indexOf(event.chip);\n            if (this._isValidIndex(chipIndex)) {\n                this._keyManager.updateActiveItem(chipIndex);\n            }\n            this.stateChanges.next();\n        });\n        this._chipBlurSubscription = this.chipBlurChanges.subscribe(() => {\n            this._blur();\n            this.stateChanges.next();\n        });\n    }\n    _listenToChipsRemoved() {\n        this._chipRemoveSubscription = this.chipRemoveChanges.subscribe(event => {\n            const chip = event.chip;\n            const chipIndex = this.chips.toArray().indexOf(event.chip);\n            // In case the chip that will be removed is currently focused, we temporarily store\n            // the index in order to be able to determine an appropriate sibling chip that will\n            // receive focus.\n            if (this._isValidIndex(chipIndex) && chip._hasFocus) {\n                this._lastDestroyedChipIndex = chipIndex;\n            }\n        });\n    }\n    /** Checks whether an event comes from inside a chip element. */\n    _originatesFromChip(event) {\n        let currentElement = event.target;\n        while (currentElement && currentElement !== this._elementRef.nativeElement) {\n            if (currentElement.classList.contains('mat-chip')) {\n                return true;\n            }\n            currentElement = currentElement.parentElement;\n        }\n        return false;\n    }\n    /** Checks whether any of the chips is focused. */\n    _hasFocusedChip() {\n        return this.chips && this.chips.some(chip => chip._hasFocus);\n    }\n    /** Syncs the list's state with the individual chips. */\n    _syncChipsState() {\n        if (this.chips) {\n            this.chips.forEach(chip => {\n                chip._chipListDisabled = this._disabled;\n                chip._chipListMultiple = this.multiple;\n            });\n        }\n    }\n}\nMatChipList.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatChipList, deps: [{ token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i1$1.Directionality, optional: true }, { token: i2.NgForm, optional: true }, { token: i2.FormGroupDirective, optional: true }, { token: i3.ErrorStateMatcher }, { token: i2.NgControl, optional: true, self: true }], target: i0.ɵɵFactoryTarget.Component });\nMatChipList.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.3.0\", type: MatChipList, selector: \"mat-chip-list\", inputs: { errorStateMatcher: \"errorStateMatcher\", multiple: \"multiple\", compareWith: \"compareWith\", value: \"value\", required: \"required\", placeholder: \"placeholder\", disabled: \"disabled\", ariaOrientation: [\"aria-orientation\", \"ariaOrientation\"], selectable: \"selectable\", tabIndex: \"tabIndex\" }, outputs: { change: \"change\", valueChange: \"valueChange\" }, host: { listeners: { \"focus\": \"focus()\", \"blur\": \"_blur()\", \"keydown\": \"_keydown($event)\" }, properties: { \"attr.tabindex\": \"disabled ? null : _tabIndex\", \"attr.aria-describedby\": \"_ariaDescribedby || null\", \"attr.aria-required\": \"role ? required : null\", \"attr.aria-disabled\": \"disabled.toString()\", \"attr.aria-invalid\": \"errorState\", \"attr.aria-multiselectable\": \"multiple\", \"attr.role\": \"role\", \"class.mat-chip-list-disabled\": \"disabled\", \"class.mat-chip-list-invalid\": \"errorState\", \"class.mat-chip-list-required\": \"required\", \"attr.aria-orientation\": \"ariaOrientation\", \"id\": \"_uid\" }, classAttribute: \"mat-chip-list\" }, providers: [{ provide: MatFormFieldControl, useExisting: MatChipList }], queries: [{ propertyName: \"chips\", predicate: MatChip, descendants: true }], exportAs: [\"matChipList\"], usesInheritance: true, ngImport: i0, template: `<div class=\"mat-chip-list-wrapper\"><ng-content></ng-content></div>`, isInline: true, styles: [\".mat-chip{position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;border:none;-webkit-appearance:none;-moz-appearance:none}.mat-standard-chip{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:inline-flex;padding:7px 12px;border-radius:16px;align-items:center;cursor:default;min-height:32px;height:1px}._mat-animation-noopable.mat-standard-chip{transition:none;animation:none}.mat-standard-chip .mat-chip-remove{border:none;-webkit-appearance:none;-moz-appearance:none;padding:0;background:none}.mat-standard-chip .mat-chip-remove.mat-icon,.mat-standard-chip .mat-chip-remove .mat-icon{width:18px;height:18px;font-size:18px}.mat-standard-chip::after{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit;opacity:0;content:\\\"\\\";pointer-events:none;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-standard-chip:hover::after{opacity:.12}.mat-standard-chip:focus{outline:none}.mat-standard-chip:focus::after{opacity:.16}.cdk-high-contrast-active .mat-standard-chip{outline:solid 1px}.cdk-high-contrast-active .mat-standard-chip:focus{outline:dotted 2px}.cdk-high-contrast-active .mat-standard-chip.mat-chip-selected{outline-width:3px}.mat-standard-chip.mat-chip-disabled::after{opacity:0}.mat-standard-chip.mat-chip-disabled .mat-chip-remove,.mat-standard-chip.mat-chip-disabled .mat-chip-trailing-icon{cursor:default}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar,.mat-standard-chip.mat-chip-with-avatar{padding-top:0;padding-bottom:0}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-right:8px;padding-left:0}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-left:8px;padding-right:0}.mat-standard-chip.mat-chip-with-trailing-icon{padding-top:7px;padding-bottom:7px;padding-right:8px;padding-left:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon{padding-left:8px;padding-right:12px}.mat-standard-chip.mat-chip-with-avatar{padding-left:0;padding-right:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-avatar{padding-right:0;padding-left:12px}.mat-standard-chip .mat-chip-avatar{width:24px;height:24px;margin-right:8px;margin-left:4px}[dir=rtl] .mat-standard-chip .mat-chip-avatar{margin-left:8px;margin-right:4px}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{width:18px;height:18px;cursor:pointer}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-standard-chip .mat-chip-remove,[dir=rtl] .mat-standard-chip .mat-chip-trailing-icon{margin-right:8px;margin-left:0}.mat-chip-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit;overflow:hidden;transform:translateZ(0)}.mat-chip-list-wrapper{display:flex;flex-direction:row;flex-wrap:wrap;align-items:center;margin:-4px}.mat-chip-list-wrapper input.mat-input-element,.mat-chip-list-wrapper .mat-standard-chip{margin:4px}.mat-chip-list-stacked .mat-chip-list-wrapper{flex-direction:column;align-items:flex-start}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-standard-chip{width:100%}.mat-chip-avatar{border-radius:50%;justify-content:center;align-items:center;display:flex;overflow:hidden;object-fit:cover}input.mat-chip-input{width:150px;margin:4px;flex:1 0 150px}\\n\"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatChipList, decorators: [{\n            type: Component,\n            args: [{ selector: 'mat-chip-list', template: `<div class=\"mat-chip-list-wrapper\"><ng-content></ng-content></div>`, exportAs: 'matChipList', host: {\n                        '[attr.tabindex]': 'disabled ? null : _tabIndex',\n                        '[attr.aria-describedby]': '_ariaDescribedby || null',\n                        '[attr.aria-required]': 'role ? required : null',\n                        '[attr.aria-disabled]': 'disabled.toString()',\n                        '[attr.aria-invalid]': 'errorState',\n                        '[attr.aria-multiselectable]': 'multiple',\n                        '[attr.role]': 'role',\n                        '[class.mat-chip-list-disabled]': 'disabled',\n                        '[class.mat-chip-list-invalid]': 'errorState',\n                        '[class.mat-chip-list-required]': 'required',\n                        '[attr.aria-orientation]': 'ariaOrientation',\n                        'class': 'mat-chip-list',\n                        '(focus)': 'focus()',\n                        '(blur)': '_blur()',\n                        '(keydown)': '_keydown($event)',\n                        '[id]': '_uid',\n                    }, providers: [{ provide: MatFormFieldControl, useExisting: MatChipList }], encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, styles: [\".mat-chip{position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;border:none;-webkit-appearance:none;-moz-appearance:none}.mat-standard-chip{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:inline-flex;padding:7px 12px;border-radius:16px;align-items:center;cursor:default;min-height:32px;height:1px}._mat-animation-noopable.mat-standard-chip{transition:none;animation:none}.mat-standard-chip .mat-chip-remove{border:none;-webkit-appearance:none;-moz-appearance:none;padding:0;background:none}.mat-standard-chip .mat-chip-remove.mat-icon,.mat-standard-chip .mat-chip-remove .mat-icon{width:18px;height:18px;font-size:18px}.mat-standard-chip::after{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit;opacity:0;content:\\\"\\\";pointer-events:none;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-standard-chip:hover::after{opacity:.12}.mat-standard-chip:focus{outline:none}.mat-standard-chip:focus::after{opacity:.16}.cdk-high-contrast-active .mat-standard-chip{outline:solid 1px}.cdk-high-contrast-active .mat-standard-chip:focus{outline:dotted 2px}.cdk-high-contrast-active .mat-standard-chip.mat-chip-selected{outline-width:3px}.mat-standard-chip.mat-chip-disabled::after{opacity:0}.mat-standard-chip.mat-chip-disabled .mat-chip-remove,.mat-standard-chip.mat-chip-disabled .mat-chip-trailing-icon{cursor:default}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar,.mat-standard-chip.mat-chip-with-avatar{padding-top:0;padding-bottom:0}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-right:8px;padding-left:0}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-left:8px;padding-right:0}.mat-standard-chip.mat-chip-with-trailing-icon{padding-top:7px;padding-bottom:7px;padding-right:8px;padding-left:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon{padding-left:8px;padding-right:12px}.mat-standard-chip.mat-chip-with-avatar{padding-left:0;padding-right:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-avatar{padding-right:0;padding-left:12px}.mat-standard-chip .mat-chip-avatar{width:24px;height:24px;margin-right:8px;margin-left:4px}[dir=rtl] .mat-standard-chip .mat-chip-avatar{margin-left:8px;margin-right:4px}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{width:18px;height:18px;cursor:pointer}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-standard-chip .mat-chip-remove,[dir=rtl] .mat-standard-chip .mat-chip-trailing-icon{margin-right:8px;margin-left:0}.mat-chip-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit;overflow:hidden;transform:translateZ(0)}.mat-chip-list-wrapper{display:flex;flex-direction:row;flex-wrap:wrap;align-items:center;margin:-4px}.mat-chip-list-wrapper input.mat-input-element,.mat-chip-list-wrapper .mat-standard-chip{margin:4px}.mat-chip-list-stacked .mat-chip-list-wrapper{flex-direction:column;align-items:flex-start}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-standard-chip{width:100%}.mat-chip-avatar{border-radius:50%;justify-content:center;align-items:center;display:flex;overflow:hidden;object-fit:cover}input.mat-chip-input{width:150px;margin:4px;flex:1 0 150px}\\n\"] }]\n        }], ctorParameters: function () {\n        return [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i1$1.Directionality, decorators: [{\n                        type: Optional\n                    }] }, { type: i2.NgForm, decorators: [{\n                        type: Optional\n                    }] }, { type: i2.FormGroupDirective, decorators: [{\n                        type: Optional\n                    }] }, { type: i3.ErrorStateMatcher }, { type: i2.NgControl, decorators: [{\n                        type: Optional\n                    }, {\n                        type: Self\n                    }] }];\n    }, propDecorators: { errorStateMatcher: [{\n                type: Input\n            }], multiple: [{\n                type: Input\n            }], compareWith: [{\n                type: Input\n            }], value: [{\n                type: Input\n            }], required: [{\n                type: Input\n            }], placeholder: [{\n                type: Input\n            }], disabled: [{\n                type: Input\n            }], ariaOrientation: [{\n                type: Input,\n                args: ['aria-orientation']\n            }], selectable: [{\n                type: Input\n            }], tabIndex: [{\n                type: Input\n            }], change: [{\n                type: Output\n            }], valueChange: [{\n                type: Output\n            }], chips: [{\n                type: ContentChildren,\n                args: [MatChip, {\n                        // We need to use `descendants: true`, because Ivy will no longer match\n                        // indirect descendants if it's left as false.\n                        descendants: true,\n                    }]\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst CHIP_DECLARATIONS = [\n    MatChipList,\n    MatChip,\n    MatChipInput,\n    MatChipRemove,\n    MatChipAvatar,\n    MatChipTrailingIcon,\n];\nclass MatChipsModule {\n}\nMatChipsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatChipsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nMatChipsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatChipsModule, declarations: [MatChipList,\n        MatChip,\n        MatChipInput,\n        MatChipRemove,\n        MatChipAvatar,\n        MatChipTrailingIcon], imports: [MatCommonModule], exports: [MatChipList,\n        MatChip,\n        MatChipInput,\n        MatChipRemove,\n        MatChipAvatar,\n        MatChipTrailingIcon] });\nMatChipsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatChipsModule, providers: [\n        ErrorStateMatcher,\n        {\n            provide: MAT_CHIPS_DEFAULT_OPTIONS,\n            useValue: {\n                separatorKeyCodes: [ENTER],\n            },\n        },\n    ], imports: [[MatCommonModule]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatChipsModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [MatCommonModule],\n                    exports: CHIP_DECLARATIONS,\n                    declarations: CHIP_DECLARATIONS,\n                    providers: [\n                        ErrorStateMatcher,\n                        {\n                            provide: MAT_CHIPS_DEFAULT_OPTIONS,\n                            useValue: {\n                                separatorKeyCodes: [ENTER],\n                            },\n                        },\n                    ],\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_CHIPS_DEFAULT_OPTIONS, MAT_CHIP_AVATAR, MAT_CHIP_REMOVE, MAT_CHIP_TRAILING_ICON, MatChip, MatChipAvatar, MatChipInput, MatChipList, MatChipListChange, MatChipRemove, MatChipSelectionChange, MatChipTrailingIcon, MatChipsModule };\n","import * as i7 from '@angular/cdk/overlay';\nimport { Overlay, CdkConnectedOverlay, OverlayModule } from '@angular/cdk/overlay';\nimport * as i8 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Directive, EventEmitter, Optional, Inject, Self, Attribute, ViewChild, Input, Output, Component, ViewEncapsulation, ChangeDetectionStrategy, ContentChildren, ContentChild, NgModule } from '@angular/core';\nimport * as i2 from '@angular/material/core';\nimport { mixinDisableRipple, mixinTabIndex, mixinDisabled, mixinErrorState, _countGroupLabelsBeforeOption, _getOptionScrollPosition, MAT_OPTION_PARENT_COMPONENT, MatOption, MAT_OPTGROUP, MatOptionModule, MatCommonModule } from '@angular/material/core';\nimport * as i6 from '@angular/material/form-field';\nimport { MAT_FORM_FIELD, MatFormFieldControl, MatFormFieldModule } from '@angular/material/form-field';\nimport * as i1 from '@angular/cdk/scrolling';\nimport { CdkScrollableModule } from '@angular/cdk/scrolling';\nimport * as i5 from '@angular/cdk/a11y';\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\nimport { SelectionModel } from '@angular/cdk/collections';\nimport { DOWN_ARROW, UP_ARROW, LEFT_ARROW, RIGHT_ARROW, ENTER, SPACE, hasModifierKey, A } from '@angular/cdk/keycodes';\nimport * as i4 from '@angular/forms';\nimport { Validators } from '@angular/forms';\nimport { Subject, defer, merge } from 'rxjs';\nimport { startWith, switchMap, take, filter, map, distinctUntilChanged, takeUntil } from 'rxjs/operators';\nimport { trigger, transition, query, animateChild, state, style, animate } from '@angular/animations';\nimport * as i3 from '@angular/cdk/bidi';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * The following are all the animations for the mat-select component, with each\n * const containing the metadata for one animation.\n *\n * The values below match the implementation of the AngularJS Material mat-select animation.\n * @docs-private\n */\nconst matSelectAnimations = {\n    /**\n     * This animation ensures the select's overlay panel animation (transformPanel) is called when\n     * closing the select.\n     * This is needed due to https://github.com/angular/angular/issues/23302\n     */\n    transformPanelWrap: trigger('transformPanelWrap', [\n        transition('* => void', query('@transformPanel', [animateChild()], { optional: true })),\n    ]),\n    /**\n     * This animation transforms the select's overlay panel on and off the page.\n     *\n     * When the panel is attached to the DOM, it expands its width by the amount of padding, scales it\n     * up to 100% on the Y axis, fades in its border, and translates slightly up and to the\n     * side to ensure the option text correctly overlaps the trigger text.\n     *\n     * When the panel is removed from the DOM, it simply fades out linearly.\n     */\n    transformPanel: trigger('transformPanel', [\n        state('void', style({\n            transform: 'scaleY(0.8)',\n            minWidth: '100%',\n            opacity: 0,\n        })),\n        state('showing', style({\n            opacity: 1,\n            minWidth: 'calc(100% + 32px)',\n            transform: 'scaleY(1)',\n        })),\n        state('showing-multiple', style({\n            opacity: 1,\n            minWidth: 'calc(100% + 64px)',\n            transform: 'scaleY(1)',\n        })),\n        transition('void => *', animate('120ms cubic-bezier(0, 0, 0.2, 1)')),\n        transition('* => void', animate('100ms 25ms linear', style({ opacity: 0 }))),\n    ]),\n};\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Returns an exception to be thrown when attempting to change a select's `multiple` option\n * after initialization.\n * @docs-private\n */\nfunction getMatSelectDynamicMultipleError() {\n    return Error('Cannot change `multiple` mode of select after initialization.');\n}\n/**\n * Returns an exception to be thrown when attempting to assign a non-array value to a select\n * in `multiple` mode. Note that `undefined` and `null` are still valid values to allow for\n * resetting the value.\n * @docs-private\n */\nfunction getMatSelectNonArrayValueError() {\n    return Error('Value must be an array in multiple-selection mode.');\n}\n/**\n * Returns an exception to be thrown when assigning a non-function value to the comparator\n * used to determine if a value corresponds to an option. Note that whether the function\n * actually takes two values and returns a boolean is not checked.\n */\nfunction getMatSelectNonFunctionValueError() {\n    return Error('`compareWith` must be a function.');\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet nextUniqueId = 0;\n/**\n * The following style constants are necessary to save here in order\n * to properly calculate the alignment of the selected option over\n * the trigger element.\n */\n/** The max height of the select's overlay panel. */\nconst SELECT_PANEL_MAX_HEIGHT = 256;\n/** The panel's padding on the x-axis. */\nconst SELECT_PANEL_PADDING_X = 16;\n/** The panel's x axis padding if it is indented (e.g. there is an option group). */\nconst SELECT_PANEL_INDENT_PADDING_X = SELECT_PANEL_PADDING_X * 2;\n/** The height of the select items in `em` units. */\nconst SELECT_ITEM_HEIGHT_EM = 3;\n// TODO(josephperrott): Revert to a constant after 2018 spec updates are fully merged.\n/**\n * Distance between the panel edge and the option text in\n * multi-selection mode.\n *\n * Calculated as:\n * (SELECT_PANEL_PADDING_X * 1.5) + 16 = 40\n * The padding is multiplied by 1.5 because the checkbox's margin is half the padding.\n * The checkbox width is 16px.\n */\nconst SELECT_MULTIPLE_PANEL_PADDING_X = SELECT_PANEL_PADDING_X * 1.5 + 16;\n/**\n * The select panel will only \"fit\" inside the viewport if it is positioned at\n * this value or more away from the viewport boundary.\n */\nconst SELECT_PANEL_VIEWPORT_PADDING = 8;\n/** Injection token that determines the scroll handling while a select is open. */\nconst MAT_SELECT_SCROLL_STRATEGY = new InjectionToken('mat-select-scroll-strategy');\n/** @docs-private */\nfunction MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return () => overlay.scrollStrategies.reposition();\n}\n/** Injection token that can be used to provide the default options the select module. */\nconst MAT_SELECT_CONFIG = new InjectionToken('MAT_SELECT_CONFIG');\n/** @docs-private */\nconst MAT_SELECT_SCROLL_STRATEGY_PROVIDER = {\n    provide: MAT_SELECT_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n/** Change event object that is emitted when the select value has changed. */\nclass MatSelectChange {\n    constructor(\n    /** Reference to the select that emitted the change event. */\n    source, \n    /** Current value of the select that emitted the event. */\n    value) {\n        this.source = source;\n        this.value = value;\n    }\n}\n// Boilerplate for applying mixins to MatSelect.\n/** @docs-private */\nconst _MatSelectMixinBase = mixinDisableRipple(mixinTabIndex(mixinDisabled(mixinErrorState(class {\n    constructor(_elementRef, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {\n        this._elementRef = _elementRef;\n        this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n        this._parentForm = _parentForm;\n        this._parentFormGroup = _parentFormGroup;\n        this.ngControl = ngControl;\n    }\n}))));\n/**\n * Injection token that can be used to reference instances of `MatSelectTrigger`. It serves as\n * alternative token to the actual `MatSelectTrigger` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst MAT_SELECT_TRIGGER = new InjectionToken('MatSelectTrigger');\n/**\n * Allows the user to customize the trigger that is displayed when the select has a value.\n */\nclass MatSelectTrigger {\n}\nMatSelectTrigger.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatSelectTrigger, deps: [], target: i0.ɵɵFactoryTarget.Directive });\nMatSelectTrigger.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.0\", type: MatSelectTrigger, selector: \"mat-select-trigger\", providers: [{ provide: MAT_SELECT_TRIGGER, useExisting: MatSelectTrigger }], ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatSelectTrigger, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'mat-select-trigger',\n                    providers: [{ provide: MAT_SELECT_TRIGGER, useExisting: MatSelectTrigger }],\n                }]\n        }] });\n/** Base class with all of the `MatSelect` functionality. */\nclass _MatSelectBase extends _MatSelectMixinBase {\n    constructor(_viewportRuler, _changeDetectorRef, _ngZone, _defaultErrorStateMatcher, elementRef, _dir, _parentForm, _parentFormGroup, _parentFormField, ngControl, tabIndex, scrollStrategyFactory, _liveAnnouncer, _defaultOptions) {\n        var _a, _b, _c;\n        super(elementRef, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n        this._viewportRuler = _viewportRuler;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._ngZone = _ngZone;\n        this._dir = _dir;\n        this._parentFormField = _parentFormField;\n        this._liveAnnouncer = _liveAnnouncer;\n        this._defaultOptions = _defaultOptions;\n        /** Whether or not the overlay panel is open. */\n        this._panelOpen = false;\n        /** Comparison function to specify which option is displayed. Defaults to object equality. */\n        this._compareWith = (o1, o2) => o1 === o2;\n        /** Unique id for this input. */\n        this._uid = `mat-select-${nextUniqueId++}`;\n        /** Current `ariar-labelledby` value for the select trigger. */\n        this._triggerAriaLabelledBy = null;\n        /** Emits whenever the component is destroyed. */\n        this._destroy = new Subject();\n        /** `View -> model callback called when value changes` */\n        this._onChange = () => { };\n        /** `View -> model callback called when select has been touched` */\n        this._onTouched = () => { };\n        /** ID for the DOM node containing the select's value. */\n        this._valueId = `mat-select-value-${nextUniqueId++}`;\n        /** Emits when the panel element is finished transforming in. */\n        this._panelDoneAnimatingStream = new Subject();\n        this._overlayPanelClass = ((_a = this._defaultOptions) === null || _a === void 0 ? void 0 : _a.overlayPanelClass) || '';\n        this._focused = false;\n        /** A name for this control that can be used by `mat-form-field`. */\n        this.controlType = 'mat-select';\n        this._multiple = false;\n        this._disableOptionCentering = (_c = (_b = this._defaultOptions) === null || _b === void 0 ? void 0 : _b.disableOptionCentering) !== null && _c !== void 0 ? _c : false;\n        /** Aria label of the select. */\n        this.ariaLabel = '';\n        /** Combined stream of all of the child options' change events. */\n        this.optionSelectionChanges = defer(() => {\n            const options = this.options;\n            if (options) {\n                return options.changes.pipe(startWith(options), switchMap(() => merge(...options.map(option => option.onSelectionChange))));\n            }\n            return this._ngZone.onStable.pipe(take(1), switchMap(() => this.optionSelectionChanges));\n        });\n        /** Event emitted when the select panel has been toggled. */\n        this.openedChange = new EventEmitter();\n        /** Event emitted when the select has been opened. */\n        this._openedStream = this.openedChange.pipe(filter(o => o), map(() => { }));\n        /** Event emitted when the select has been closed. */\n        this._closedStream = this.openedChange.pipe(filter(o => !o), map(() => { }));\n        /** Event emitted when the selected value has been changed by the user. */\n        this.selectionChange = new EventEmitter();\n        /**\n         * Event that emits whenever the raw value of the select changes. This is here primarily\n         * to facilitate the two-way binding for the `value` input.\n         * @docs-private\n         */\n        this.valueChange = new EventEmitter();\n        if (this.ngControl) {\n            // Note: we provide the value accessor through here, instead of\n            // the `providers` to avoid running into a circular import.\n            this.ngControl.valueAccessor = this;\n        }\n        // Note that we only want to set this when the defaults pass it in, otherwise it should\n        // stay as `undefined` so that it falls back to the default in the key manager.\n        if ((_defaultOptions === null || _defaultOptions === void 0 ? void 0 : _defaultOptions.typeaheadDebounceInterval) != null) {\n            this._typeaheadDebounceInterval = _defaultOptions.typeaheadDebounceInterval;\n        }\n        this._scrollStrategyFactory = scrollStrategyFactory;\n        this._scrollStrategy = this._scrollStrategyFactory();\n        this.tabIndex = parseInt(tabIndex) || 0;\n        // Force setter to be called in case id was not specified.\n        this.id = this.id;\n    }\n    /** Whether the select is focused. */\n    get focused() {\n        return this._focused || this._panelOpen;\n    }\n    /** Placeholder to be shown if no value has been selected. */\n    get placeholder() {\n        return this._placeholder;\n    }\n    set placeholder(value) {\n        this._placeholder = value;\n        this.stateChanges.next();\n    }\n    /** Whether the component is required. */\n    get required() {\n        var _a, _b, _c, _d;\n        return (_d = (_a = this._required) !== null && _a !== void 0 ? _a : (_c = (_b = this.ngControl) === null || _b === void 0 ? void 0 : _b.control) === null || _c === void 0 ? void 0 : _c.hasValidator(Validators.required)) !== null && _d !== void 0 ? _d : false;\n    }\n    set required(value) {\n        this._required = coerceBooleanProperty(value);\n        this.stateChanges.next();\n    }\n    /** Whether the user should be allowed to select multiple options. */\n    get multiple() {\n        return this._multiple;\n    }\n    set multiple(value) {\n        if (this._selectionModel && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getMatSelectDynamicMultipleError();\n        }\n        this._multiple = coerceBooleanProperty(value);\n    }\n    /** Whether to center the active option over the trigger. */\n    get disableOptionCentering() {\n        return this._disableOptionCentering;\n    }\n    set disableOptionCentering(value) {\n        this._disableOptionCentering = coerceBooleanProperty(value);\n    }\n    /**\n     * Function to compare the option values with the selected values. The first argument\n     * is a value from an option. The second is a value from the selection. A boolean\n     * should be returned.\n     */\n    get compareWith() {\n        return this._compareWith;\n    }\n    set compareWith(fn) {\n        if (typeof fn !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getMatSelectNonFunctionValueError();\n        }\n        this._compareWith = fn;\n        if (this._selectionModel) {\n            // A different comparator means the selection could change.\n            this._initializeSelection();\n        }\n    }\n    /** Value of the select control. */\n    get value() {\n        return this._value;\n    }\n    set value(newValue) {\n        const hasAssigned = this._assignValue(newValue);\n        if (hasAssigned) {\n            this._onChange(newValue);\n        }\n    }\n    /** Time to wait in milliseconds after the last keystroke before moving focus to an item. */\n    get typeaheadDebounceInterval() {\n        return this._typeaheadDebounceInterval;\n    }\n    set typeaheadDebounceInterval(value) {\n        this._typeaheadDebounceInterval = coerceNumberProperty(value);\n    }\n    /** Unique id of the element. */\n    get id() {\n        return this._id;\n    }\n    set id(value) {\n        this._id = value || this._uid;\n        this.stateChanges.next();\n    }\n    ngOnInit() {\n        this._selectionModel = new SelectionModel(this.multiple);\n        this.stateChanges.next();\n        // We need `distinctUntilChanged` here, because some browsers will\n        // fire the animation end event twice for the same animation. See:\n        // https://github.com/angular/angular/issues/24084\n        this._panelDoneAnimatingStream\n            .pipe(distinctUntilChanged(), takeUntil(this._destroy))\n            .subscribe(() => this._panelDoneAnimating(this.panelOpen));\n    }\n    ngAfterContentInit() {\n        this._initKeyManager();\n        this._selectionModel.changed.pipe(takeUntil(this._destroy)).subscribe(event => {\n            event.added.forEach(option => option.select());\n            event.removed.forEach(option => option.deselect());\n        });\n        this.options.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe(() => {\n            this._resetOptions();\n            this._initializeSelection();\n        });\n    }\n    ngDoCheck() {\n        const newAriaLabelledby = this._getTriggerAriaLabelledby();\n        const ngControl = this.ngControl;\n        // We have to manage setting the `aria-labelledby` ourselves, because part of its value\n        // is computed as a result of a content query which can cause this binding to trigger a\n        // \"changed after checked\" error.\n        if (newAriaLabelledby !== this._triggerAriaLabelledBy) {\n            const element = this._elementRef.nativeElement;\n            this._triggerAriaLabelledBy = newAriaLabelledby;\n            if (newAriaLabelledby) {\n                element.setAttribute('aria-labelledby', newAriaLabelledby);\n            }\n            else {\n                element.removeAttribute('aria-labelledby');\n            }\n        }\n        if (ngControl) {\n            // The disabled state might go out of sync if the form group is swapped out. See #17860.\n            if (this._previousControl !== ngControl.control) {\n                if (this._previousControl !== undefined &&\n                    ngControl.disabled !== null &&\n                    ngControl.disabled !== this.disabled) {\n                    this.disabled = ngControl.disabled;\n                }\n                this._previousControl = ngControl.control;\n            }\n            this.updateErrorState();\n        }\n    }\n    ngOnChanges(changes) {\n        // Updating the disabled state is handled by `mixinDisabled`, but we need to additionally let\n        // the parent form field know to run change detection when the disabled state changes.\n        if (changes['disabled']) {\n            this.stateChanges.next();\n        }\n        if (changes['typeaheadDebounceInterval'] && this._keyManager) {\n            this._keyManager.withTypeAhead(this._typeaheadDebounceInterval);\n        }\n    }\n    ngOnDestroy() {\n        this._destroy.next();\n        this._destroy.complete();\n        this.stateChanges.complete();\n    }\n    /** Toggles the overlay panel open or closed. */\n    toggle() {\n        this.panelOpen ? this.close() : this.open();\n    }\n    /** Opens the overlay panel. */\n    open() {\n        if (this._canOpen()) {\n            this._panelOpen = true;\n            this._keyManager.withHorizontalOrientation(null);\n            this._highlightCorrectOption();\n            this._changeDetectorRef.markForCheck();\n        }\n    }\n    /** Closes the overlay panel and focuses the host element. */\n    close() {\n        if (this._panelOpen) {\n            this._panelOpen = false;\n            this._keyManager.withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr');\n            this._changeDetectorRef.markForCheck();\n            this._onTouched();\n        }\n    }\n    /**\n     * Sets the select's value. Part of the ControlValueAccessor interface\n     * required to integrate with Angular's core forms API.\n     *\n     * @param value New value to be written to the model.\n     */\n    writeValue(value) {\n        this._assignValue(value);\n    }\n    /**\n     * Saves a callback function to be invoked when the select's value\n     * changes from user input. Part of the ControlValueAccessor interface\n     * required to integrate with Angular's core forms API.\n     *\n     * @param fn Callback to be triggered when the value changes.\n     */\n    registerOnChange(fn) {\n        this._onChange = fn;\n    }\n    /**\n     * Saves a callback function to be invoked when the select is blurred\n     * by the user. Part of the ControlValueAccessor interface required\n     * to integrate with Angular's core forms API.\n     *\n     * @param fn Callback to be triggered when the component has been touched.\n     */\n    registerOnTouched(fn) {\n        this._onTouched = fn;\n    }\n    /**\n     * Disables the select. Part of the ControlValueAccessor interface required\n     * to integrate with Angular's core forms API.\n     *\n     * @param isDisabled Sets whether the component is disabled.\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n        this._changeDetectorRef.markForCheck();\n        this.stateChanges.next();\n    }\n    /** Whether or not the overlay panel is open. */\n    get panelOpen() {\n        return this._panelOpen;\n    }\n    /** The currently selected option. */\n    get selected() {\n        var _a, _b;\n        return this.multiple ? ((_a = this._selectionModel) === null || _a === void 0 ? void 0 : _a.selected) || [] : (_b = this._selectionModel) === null || _b === void 0 ? void 0 : _b.selected[0];\n    }\n    /** The value displayed in the trigger. */\n    get triggerValue() {\n        if (this.empty) {\n            return '';\n        }\n        if (this._multiple) {\n            const selectedOptions = this._selectionModel.selected.map(option => option.viewValue);\n            if (this._isRtl()) {\n                selectedOptions.reverse();\n            }\n            // TODO(crisbeto): delimiter should be configurable for proper localization.\n            return selectedOptions.join(', ');\n        }\n        return this._selectionModel.selected[0].viewValue;\n    }\n    /** Whether the element is in RTL mode. */\n    _isRtl() {\n        return this._dir ? this._dir.value === 'rtl' : false;\n    }\n    /** Handles all keydown events on the select. */\n    _handleKeydown(event) {\n        if (!this.disabled) {\n            this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);\n        }\n    }\n    /** Handles keyboard events while the select is closed. */\n    _handleClosedKeydown(event) {\n        const keyCode = event.keyCode;\n        const isArrowKey = keyCode === DOWN_ARROW ||\n            keyCode === UP_ARROW ||\n            keyCode === LEFT_ARROW ||\n            keyCode === RIGHT_ARROW;\n        const isOpenKey = keyCode === ENTER || keyCode === SPACE;\n        const manager = this._keyManager;\n        // Open the select on ALT + arrow key to match the native <select>\n        if ((!manager.isTyping() && isOpenKey && !hasModifierKey(event)) ||\n            ((this.multiple || event.altKey) && isArrowKey)) {\n            event.preventDefault(); // prevents the page from scrolling down when pressing space\n            this.open();\n        }\n        else if (!this.multiple) {\n            const previouslySelectedOption = this.selected;\n            manager.onKeydown(event);\n            const selectedOption = this.selected;\n            // Since the value has changed, we need to announce it ourselves.\n            if (selectedOption && previouslySelectedOption !== selectedOption) {\n                // We set a duration on the live announcement, because we want the live element to be\n                // cleared after a while so that users can't navigate to it using the arrow keys.\n                this._liveAnnouncer.announce(selectedOption.viewValue, 10000);\n            }\n        }\n    }\n    /** Handles keyboard events when the selected is open. */\n    _handleOpenKeydown(event) {\n        const manager = this._keyManager;\n        const keyCode = event.keyCode;\n        const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW;\n        const isTyping = manager.isTyping();\n        if (isArrowKey && event.altKey) {\n            // Close the select on ALT + arrow key to match the native <select>\n            event.preventDefault();\n            this.close();\n            // Don't do anything in this case if the user is typing,\n            // because the typing sequence can include the space key.\n        }\n        else if (!isTyping &&\n            (keyCode === ENTER || keyCode === SPACE) &&\n            manager.activeItem &&\n            !hasModifierKey(event)) {\n            event.preventDefault();\n            manager.activeItem._selectViaInteraction();\n        }\n        else if (!isTyping && this._multiple && keyCode === A && event.ctrlKey) {\n            event.preventDefault();\n            const hasDeselectedOptions = this.options.some(opt => !opt.disabled && !opt.selected);\n            this.options.forEach(option => {\n                if (!option.disabled) {\n                    hasDeselectedOptions ? option.select() : option.deselect();\n                }\n            });\n        }\n        else {\n            const previouslyFocusedIndex = manager.activeItemIndex;\n            manager.onKeydown(event);\n            if (this._multiple &&\n                isArrowKey &&\n                event.shiftKey &&\n                manager.activeItem &&\n                manager.activeItemIndex !== previouslyFocusedIndex) {\n                manager.activeItem._selectViaInteraction();\n            }\n        }\n    }\n    _onFocus() {\n        if (!this.disabled) {\n            this._focused = true;\n            this.stateChanges.next();\n        }\n    }\n    /**\n     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will\n     * \"blur\" to the panel when it opens, causing a false positive.\n     */\n    _onBlur() {\n        this._focused = false;\n        if (!this.disabled && !this.panelOpen) {\n            this._onTouched();\n            this._changeDetectorRef.markForCheck();\n            this.stateChanges.next();\n        }\n    }\n    /**\n     * Callback that is invoked when the overlay panel has been attached.\n     */\n    _onAttached() {\n        this._overlayDir.positionChange.pipe(take(1)).subscribe(() => {\n            this._changeDetectorRef.detectChanges();\n            this._positioningSettled();\n        });\n    }\n    /** Returns the theme to be used on the panel. */\n    _getPanelTheme() {\n        return this._parentFormField ? `mat-${this._parentFormField.color}` : '';\n    }\n    /** Whether the select has a value. */\n    get empty() {\n        return !this._selectionModel || this._selectionModel.isEmpty();\n    }\n    _initializeSelection() {\n        // Defer setting the value in order to avoid the \"Expression\n        // has changed after it was checked\" errors from Angular.\n        Promise.resolve().then(() => {\n            if (this.ngControl) {\n                this._value = this.ngControl.value;\n            }\n            this._setSelectionByValue(this._value);\n            this.stateChanges.next();\n        });\n    }\n    /**\n     * Sets the selected option based on a value. If no option can be\n     * found with the designated value, the select trigger is cleared.\n     */\n    _setSelectionByValue(value) {\n        this._selectionModel.selected.forEach(option => option.setInactiveStyles());\n        this._selectionModel.clear();\n        if (this.multiple && value) {\n            if (!Array.isArray(value) && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw getMatSelectNonArrayValueError();\n            }\n            value.forEach((currentValue) => this._selectOptionByValue(currentValue));\n            this._sortValues();\n        }\n        else {\n            const correspondingOption = this._selectOptionByValue(value);\n            // Shift focus to the active item. Note that we shouldn't do this in multiple\n            // mode, because we don't know what option the user interacted with last.\n            if (correspondingOption) {\n                this._keyManager.updateActiveItem(correspondingOption);\n            }\n            else if (!this.panelOpen) {\n                // Otherwise reset the highlighted option. Note that we only want to do this while\n                // closed, because doing it while open can shift the user's focus unnecessarily.\n                this._keyManager.updateActiveItem(-1);\n            }\n        }\n        this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * Finds and selects and option based on its value.\n     * @returns Option that has the corresponding value.\n     */\n    _selectOptionByValue(value) {\n        const correspondingOption = this.options.find((option) => {\n            // Skip options that are already in the model. This allows us to handle cases\n            // where the same primitive value is selected multiple times.\n            if (this._selectionModel.isSelected(option)) {\n                return false;\n            }\n            try {\n                // Treat null as a special reset value.\n                return option.value != null && this._compareWith(option.value, value);\n            }\n            catch (error) {\n                if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                    // Notify developers of errors in their comparator.\n                    console.warn(error);\n                }\n                return false;\n            }\n        });\n        if (correspondingOption) {\n            this._selectionModel.select(correspondingOption);\n        }\n        return correspondingOption;\n    }\n    /** Assigns a specific value to the select. Returns whether the value has changed. */\n    _assignValue(newValue) {\n        // Always re-assign an array, because it might have been mutated.\n        if (newValue !== this._value || (this._multiple && Array.isArray(newValue))) {\n            if (this.options) {\n                this._setSelectionByValue(newValue);\n            }\n            this._value = newValue;\n            return true;\n        }\n        return false;\n    }\n    /** Sets up a key manager to listen to keyboard events on the overlay panel. */\n    _initKeyManager() {\n        this._keyManager = new ActiveDescendantKeyManager(this.options)\n            .withTypeAhead(this._typeaheadDebounceInterval)\n            .withVerticalOrientation()\n            .withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr')\n            .withHomeAndEnd()\n            .withAllowedModifierKeys(['shiftKey']);\n        this._keyManager.tabOut.pipe(takeUntil(this._destroy)).subscribe(() => {\n            if (this.panelOpen) {\n                // Select the active item when tabbing away. This is consistent with how the native\n                // select behaves. Note that we only want to do this in single selection mode.\n                if (!this.multiple && this._keyManager.activeItem) {\n                    this._keyManager.activeItem._selectViaInteraction();\n                }\n                // Restore focus to the trigger before closing. Ensures that the focus\n                // position won't be lost if the user got focus into the overlay.\n                this.focus();\n                this.close();\n            }\n        });\n        this._keyManager.change.pipe(takeUntil(this._destroy)).subscribe(() => {\n            if (this._panelOpen && this.panel) {\n                this._scrollOptionIntoView(this._keyManager.activeItemIndex || 0);\n            }\n            else if (!this._panelOpen && !this.multiple && this._keyManager.activeItem) {\n                this._keyManager.activeItem._selectViaInteraction();\n            }\n        });\n    }\n    /** Drops current option subscriptions and IDs and resets from scratch. */\n    _resetOptions() {\n        const changedOrDestroyed = merge(this.options.changes, this._destroy);\n        this.optionSelectionChanges.pipe(takeUntil(changedOrDestroyed)).subscribe(event => {\n            this._onSelect(event.source, event.isUserInput);\n            if (event.isUserInput && !this.multiple && this._panelOpen) {\n                this.close();\n                this.focus();\n            }\n        });\n        // Listen to changes in the internal state of the options and react accordingly.\n        // Handles cases like the labels of the selected options changing.\n        merge(...this.options.map(option => option._stateChanges))\n            .pipe(takeUntil(changedOrDestroyed))\n            .subscribe(() => {\n            this._changeDetectorRef.markForCheck();\n            this.stateChanges.next();\n        });\n    }\n    /** Invoked when an option is clicked. */\n    _onSelect(option, isUserInput) {\n        const wasSelected = this._selectionModel.isSelected(option);\n        if (option.value == null && !this._multiple) {\n            option.deselect();\n            this._selectionModel.clear();\n            if (this.value != null) {\n                this._propagateChanges(option.value);\n            }\n        }\n        else {\n            if (wasSelected !== option.selected) {\n                option.selected\n                    ? this._selectionModel.select(option)\n                    : this._selectionModel.deselect(option);\n            }\n            if (isUserInput) {\n                this._keyManager.setActiveItem(option);\n            }\n            if (this.multiple) {\n                this._sortValues();\n                if (isUserInput) {\n                    // In case the user selected the option with their mouse, we\n                    // want to restore focus back to the trigger, in order to\n                    // prevent the select keyboard controls from clashing with\n                    // the ones from `mat-option`.\n                    this.focus();\n                }\n            }\n        }\n        if (wasSelected !== this._selectionModel.isSelected(option)) {\n            this._propagateChanges();\n        }\n        this.stateChanges.next();\n    }\n    /** Sorts the selected values in the selected based on their order in the panel. */\n    _sortValues() {\n        if (this.multiple) {\n            const options = this.options.toArray();\n            this._selectionModel.sort((a, b) => {\n                return this.sortComparator\n                    ? this.sortComparator(a, b, options)\n                    : options.indexOf(a) - options.indexOf(b);\n            });\n            this.stateChanges.next();\n        }\n    }\n    /** Emits change event to set the model value. */\n    _propagateChanges(fallbackValue) {\n        let valueToEmit = null;\n        if (this.multiple) {\n            valueToEmit = this.selected.map(option => option.value);\n        }\n        else {\n            valueToEmit = this.selected ? this.selected.value : fallbackValue;\n        }\n        this._value = valueToEmit;\n        this.valueChange.emit(valueToEmit);\n        this._onChange(valueToEmit);\n        this.selectionChange.emit(this._getChangeEvent(valueToEmit));\n        this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * Highlights the selected item. If no option is selected, it will highlight\n     * the first item instead.\n     */\n    _highlightCorrectOption() {\n        if (this._keyManager) {\n            if (this.empty) {\n                this._keyManager.setFirstItemActive();\n            }\n            else {\n                this._keyManager.setActiveItem(this._selectionModel.selected[0]);\n            }\n        }\n    }\n    /** Whether the panel is allowed to open. */\n    _canOpen() {\n        var _a;\n        return !this._panelOpen && !this.disabled && ((_a = this.options) === null || _a === void 0 ? void 0 : _a.length) > 0;\n    }\n    /** Focuses the select element. */\n    focus(options) {\n        this._elementRef.nativeElement.focus(options);\n    }\n    /** Gets the aria-labelledby for the select panel. */\n    _getPanelAriaLabelledby() {\n        var _a;\n        if (this.ariaLabel) {\n            return null;\n        }\n        const labelId = (_a = this._parentFormField) === null || _a === void 0 ? void 0 : _a.getLabelId();\n        const labelExpression = labelId ? labelId + ' ' : '';\n        return this.ariaLabelledby ? labelExpression + this.ariaLabelledby : labelId;\n    }\n    /** Determines the `aria-activedescendant` to be set on the host. */\n    _getAriaActiveDescendant() {\n        if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {\n            return this._keyManager.activeItem.id;\n        }\n        return null;\n    }\n    /** Gets the aria-labelledby of the select component trigger. */\n    _getTriggerAriaLabelledby() {\n        var _a;\n        if (this.ariaLabel) {\n            return null;\n        }\n        const labelId = (_a = this._parentFormField) === null || _a === void 0 ? void 0 : _a.getLabelId();\n        let value = (labelId ? labelId + ' ' : '') + this._valueId;\n        if (this.ariaLabelledby) {\n            value += ' ' + this.ariaLabelledby;\n        }\n        return value;\n    }\n    /** Called when the overlay panel is done animating. */\n    _panelDoneAnimating(isOpen) {\n        this.openedChange.emit(isOpen);\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    setDescribedByIds(ids) {\n        this._ariaDescribedby = ids.join(' ');\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    onContainerClick() {\n        this.focus();\n        this.open();\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get shouldLabelFloat() {\n        return this._panelOpen || !this.empty || (this._focused && !!this._placeholder);\n    }\n}\n_MatSelectBase.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: _MatSelectBase, deps: [{ token: i1.ViewportRuler }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }, { token: i2.ErrorStateMatcher }, { token: i0.ElementRef }, { token: i3.Directionality, optional: true }, { token: i4.NgForm, optional: true }, { token: i4.FormGroupDirective, optional: true }, { token: MAT_FORM_FIELD, optional: true }, { token: i4.NgControl, optional: true, self: true }, { token: 'tabindex', attribute: true }, { token: MAT_SELECT_SCROLL_STRATEGY }, { token: i5.LiveAnnouncer }, { token: MAT_SELECT_CONFIG, optional: true }], target: i0.ɵɵFactoryTarget.Directive });\n_MatSelectBase.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.3.0\", type: _MatSelectBase, inputs: { panelClass: \"panelClass\", placeholder: \"placeholder\", required: \"required\", multiple: \"multiple\", disableOptionCentering: \"disableOptionCentering\", compareWith: \"compareWith\", value: \"value\", ariaLabel: [\"aria-label\", \"ariaLabel\"], ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"], errorStateMatcher: \"errorStateMatcher\", typeaheadDebounceInterval: \"typeaheadDebounceInterval\", sortComparator: \"sortComparator\", id: \"id\" }, outputs: { openedChange: \"openedChange\", _openedStream: \"opened\", _closedStream: \"closed\", selectionChange: \"selectionChange\", valueChange: \"valueChange\" }, viewQueries: [{ propertyName: \"trigger\", first: true, predicate: [\"trigger\"], descendants: true }, { propertyName: \"panel\", first: true, predicate: [\"panel\"], descendants: true }, { propertyName: \"_overlayDir\", first: true, predicate: CdkConnectedOverlay, descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: _MatSelectBase, decorators: [{\n            type: Directive\n        }], ctorParameters: function () {\n        return [{ type: i1.ViewportRuler }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i2.ErrorStateMatcher }, { type: i0.ElementRef }, { type: i3.Directionality, decorators: [{\n                        type: Optional\n                    }] }, { type: i4.NgForm, decorators: [{\n                        type: Optional\n                    }] }, { type: i4.FormGroupDirective, decorators: [{\n                        type: Optional\n                    }] }, { type: i6.MatFormField, decorators: [{\n                        type: Optional\n                    }, {\n                        type: Inject,\n                        args: [MAT_FORM_FIELD]\n                    }] }, { type: i4.NgControl, decorators: [{\n                        type: Self\n                    }, {\n                        type: Optional\n                    }] }, { type: undefined, decorators: [{\n                        type: Attribute,\n                        args: ['tabindex']\n                    }] }, { type: undefined, decorators: [{\n                        type: Inject,\n                        args: [MAT_SELECT_SCROLL_STRATEGY]\n                    }] }, { type: i5.LiveAnnouncer }, { type: undefined, decorators: [{\n                        type: Optional\n                    }, {\n                        type: Inject,\n                        args: [MAT_SELECT_CONFIG]\n                    }] }];\n    }, propDecorators: { trigger: [{\n                type: ViewChild,\n                args: ['trigger']\n            }], panel: [{\n                type: ViewChild,\n                args: ['panel']\n            }], _overlayDir: [{\n                type: ViewChild,\n                args: [CdkConnectedOverlay]\n            }], panelClass: [{\n                type: Input\n            }], placeholder: [{\n                type: Input\n            }], required: [{\n                type: Input\n            }], multiple: [{\n                type: Input\n            }], disableOptionCentering: [{\n                type: Input\n            }], compareWith: [{\n                type: Input\n            }], value: [{\n                type: Input\n            }], ariaLabel: [{\n                type: Input,\n                args: ['aria-label']\n            }], ariaLabelledby: [{\n                type: Input,\n                args: ['aria-labelledby']\n            }], errorStateMatcher: [{\n                type: Input\n            }], typeaheadDebounceInterval: [{\n                type: Input\n            }], sortComparator: [{\n                type: Input\n            }], id: [{\n                type: Input\n            }], openedChange: [{\n                type: Output\n            }], _openedStream: [{\n                type: Output,\n                args: ['opened']\n            }], _closedStream: [{\n                type: Output,\n                args: ['closed']\n            }], selectionChange: [{\n                type: Output\n            }], valueChange: [{\n                type: Output\n            }] } });\nclass MatSelect extends _MatSelectBase {\n    constructor() {\n        super(...arguments);\n        /** The scroll position of the overlay panel, calculated to center the selected option. */\n        this._scrollTop = 0;\n        /** The cached font-size of the trigger element. */\n        this._triggerFontSize = 0;\n        /** The value of the select panel's transform-origin property. */\n        this._transformOrigin = 'top';\n        /**\n         * The y-offset of the overlay panel in relation to the trigger's top start corner.\n         * This must be adjusted to align the selected option text over the trigger text.\n         * when the panel opens. Will change based on the y-position of the selected option.\n         */\n        this._offsetY = 0;\n        this._positions = [\n            {\n                originX: 'start',\n                originY: 'top',\n                overlayX: 'start',\n                overlayY: 'top',\n            },\n            {\n                originX: 'start',\n                originY: 'bottom',\n                overlayX: 'start',\n                overlayY: 'bottom',\n            },\n        ];\n    }\n    /**\n     * Calculates the scroll position of the select's overlay panel.\n     *\n     * Attempts to center the selected option in the panel. If the option is\n     * too high or too low in the panel to be scrolled to the center, it clamps the\n     * scroll position to the min or max scroll positions respectively.\n     */\n    _calculateOverlayScroll(selectedIndex, scrollBuffer, maxScroll) {\n        const itemHeight = this._getItemHeight();\n        const optionOffsetFromScrollTop = itemHeight * selectedIndex;\n        const halfOptionHeight = itemHeight / 2;\n        // Starts at the optionOffsetFromScrollTop, which scrolls the option to the top of the\n        // scroll container, then subtracts the scroll buffer to scroll the option down to\n        // the center of the overlay panel. Half the option height must be re-added to the\n        // scrollTop so the option is centered based on its middle, not its top edge.\n        const optimalScrollPosition = optionOffsetFromScrollTop - scrollBuffer + halfOptionHeight;\n        return Math.min(Math.max(0, optimalScrollPosition), maxScroll);\n    }\n    ngOnInit() {\n        super.ngOnInit();\n        this._viewportRuler\n            .change()\n            .pipe(takeUntil(this._destroy))\n            .subscribe(() => {\n            if (this.panelOpen) {\n                this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();\n                this._changeDetectorRef.markForCheck();\n            }\n        });\n    }\n    open() {\n        if (super._canOpen()) {\n            super.open();\n            this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();\n            // Note: The computed font-size will be a string pixel value (e.g. \"16px\").\n            // `parseInt` ignores the trailing 'px' and converts this to a number.\n            this._triggerFontSize = parseInt(getComputedStyle(this.trigger.nativeElement).fontSize || '0');\n            this._calculateOverlayPosition();\n            // Set the font size on the panel element once it exists.\n            this._ngZone.onStable.pipe(take(1)).subscribe(() => {\n                if (this._triggerFontSize &&\n                    this._overlayDir.overlayRef &&\n                    this._overlayDir.overlayRef.overlayElement) {\n                    this._overlayDir.overlayRef.overlayElement.style.fontSize = `${this._triggerFontSize}px`;\n                }\n            });\n        }\n    }\n    /** Scrolls the active option into view. */\n    _scrollOptionIntoView(index) {\n        const labelCount = _countGroupLabelsBeforeOption(index, this.options, this.optionGroups);\n        const itemHeight = this._getItemHeight();\n        if (index === 0 && labelCount === 1) {\n            // If we've got one group label before the option and we're at the top option,\n            // scroll the list to the top. This is better UX than scrolling the list to the\n            // top of the option, because it allows the user to read the top group's label.\n            this.panel.nativeElement.scrollTop = 0;\n        }\n        else {\n            this.panel.nativeElement.scrollTop = _getOptionScrollPosition((index + labelCount) * itemHeight, itemHeight, this.panel.nativeElement.scrollTop, SELECT_PANEL_MAX_HEIGHT);\n        }\n    }\n    _positioningSettled() {\n        this._calculateOverlayOffsetX();\n        this.panel.nativeElement.scrollTop = this._scrollTop;\n    }\n    _panelDoneAnimating(isOpen) {\n        if (this.panelOpen) {\n            this._scrollTop = 0;\n        }\n        else {\n            this._overlayDir.offsetX = 0;\n            this._changeDetectorRef.markForCheck();\n        }\n        super._panelDoneAnimating(isOpen);\n    }\n    _getChangeEvent(value) {\n        return new MatSelectChange(this, value);\n    }\n    /**\n     * Sets the x-offset of the overlay panel in relation to the trigger's top start corner.\n     * This must be adjusted to align the selected option text over the trigger text when\n     * the panel opens. Will change based on LTR or RTL text direction. Note that the offset\n     * can't be calculated until the panel has been attached, because we need to know the\n     * content width in order to constrain the panel within the viewport.\n     */\n    _calculateOverlayOffsetX() {\n        const overlayRect = this._overlayDir.overlayRef.overlayElement.getBoundingClientRect();\n        const viewportSize = this._viewportRuler.getViewportSize();\n        const isRtl = this._isRtl();\n        const paddingWidth = this.multiple\n            ? SELECT_MULTIPLE_PANEL_PADDING_X + SELECT_PANEL_PADDING_X\n            : SELECT_PANEL_PADDING_X * 2;\n        let offsetX;\n        // Adjust the offset, depending on the option padding.\n        if (this.multiple) {\n            offsetX = SELECT_MULTIPLE_PANEL_PADDING_X;\n        }\n        else if (this.disableOptionCentering) {\n            offsetX = SELECT_PANEL_PADDING_X;\n        }\n        else {\n            let selected = this._selectionModel.selected[0] || this.options.first;\n            offsetX = selected && selected.group ? SELECT_PANEL_INDENT_PADDING_X : SELECT_PANEL_PADDING_X;\n        }\n        // Invert the offset in LTR.\n        if (!isRtl) {\n            offsetX *= -1;\n        }\n        // Determine how much the select overflows on each side.\n        const leftOverflow = 0 - (overlayRect.left + offsetX - (isRtl ? paddingWidth : 0));\n        const rightOverflow = overlayRect.right + offsetX - viewportSize.width + (isRtl ? 0 : paddingWidth);\n        // If the element overflows on either side, reduce the offset to allow it to fit.\n        if (leftOverflow > 0) {\n            offsetX += leftOverflow + SELECT_PANEL_VIEWPORT_PADDING;\n        }\n        else if (rightOverflow > 0) {\n            offsetX -= rightOverflow + SELECT_PANEL_VIEWPORT_PADDING;\n        }\n        // Set the offset directly in order to avoid having to go through change detection and\n        // potentially triggering \"changed after it was checked\" errors. Round the value to avoid\n        // blurry content in some browsers.\n        this._overlayDir.offsetX = Math.round(offsetX);\n        this._overlayDir.overlayRef.updatePosition();\n    }\n    /**\n     * Calculates the y-offset of the select's overlay panel in relation to the\n     * top start corner of the trigger. It has to be adjusted in order for the\n     * selected option to be aligned over the trigger when the panel opens.\n     */\n    _calculateOverlayOffsetY(selectedIndex, scrollBuffer, maxScroll) {\n        const itemHeight = this._getItemHeight();\n        const optionHeightAdjustment = (itemHeight - this._triggerRect.height) / 2;\n        const maxOptionsDisplayed = Math.floor(SELECT_PANEL_MAX_HEIGHT / itemHeight);\n        let optionOffsetFromPanelTop;\n        // Disable offset if requested by user by returning 0 as value to offset\n        if (this.disableOptionCentering) {\n            return 0;\n        }\n        if (this._scrollTop === 0) {\n            optionOffsetFromPanelTop = selectedIndex * itemHeight;\n        }\n        else if (this._scrollTop === maxScroll) {\n            const firstDisplayedIndex = this._getItemCount() - maxOptionsDisplayed;\n            const selectedDisplayIndex = selectedIndex - firstDisplayedIndex;\n            // The first item is partially out of the viewport. Therefore we need to calculate what\n            // portion of it is shown in the viewport and account for it in our offset.\n            let partialItemHeight = itemHeight - ((this._getItemCount() * itemHeight - SELECT_PANEL_MAX_HEIGHT) % itemHeight);\n            // Because the panel height is longer than the height of the options alone,\n            // there is always extra padding at the top or bottom of the panel. When\n            // scrolled to the very bottom, this padding is at the top of the panel and\n            // must be added to the offset.\n            optionOffsetFromPanelTop = selectedDisplayIndex * itemHeight + partialItemHeight;\n        }\n        else {\n            // If the option was scrolled to the middle of the panel using a scroll buffer,\n            // its offset will be the scroll buffer minus the half height that was added to\n            // center it.\n            optionOffsetFromPanelTop = scrollBuffer - itemHeight / 2;\n        }\n        // The final offset is the option's offset from the top, adjusted for the height difference,\n        // multiplied by -1 to ensure that the overlay moves in the correct direction up the page.\n        // The value is rounded to prevent some browsers from blurring the content.\n        return Math.round(optionOffsetFromPanelTop * -1 - optionHeightAdjustment);\n    }\n    /**\n     * Checks that the attempted overlay position will fit within the viewport.\n     * If it will not fit, tries to adjust the scroll position and the associated\n     * y-offset so the panel can open fully on-screen. If it still won't fit,\n     * sets the offset back to 0 to allow the fallback position to take over.\n     */\n    _checkOverlayWithinViewport(maxScroll) {\n        const itemHeight = this._getItemHeight();\n        const viewportSize = this._viewportRuler.getViewportSize();\n        const topSpaceAvailable = this._triggerRect.top - SELECT_PANEL_VIEWPORT_PADDING;\n        const bottomSpaceAvailable = viewportSize.height - this._triggerRect.bottom - SELECT_PANEL_VIEWPORT_PADDING;\n        const panelHeightTop = Math.abs(this._offsetY);\n        const totalPanelHeight = Math.min(this._getItemCount() * itemHeight, SELECT_PANEL_MAX_HEIGHT);\n        const panelHeightBottom = totalPanelHeight - panelHeightTop - this._triggerRect.height;\n        if (panelHeightBottom > bottomSpaceAvailable) {\n            this._adjustPanelUp(panelHeightBottom, bottomSpaceAvailable);\n        }\n        else if (panelHeightTop > topSpaceAvailable) {\n            this._adjustPanelDown(panelHeightTop, topSpaceAvailable, maxScroll);\n        }\n        else {\n            this._transformOrigin = this._getOriginBasedOnOption();\n        }\n    }\n    /** Adjusts the overlay panel up to fit in the viewport. */\n    _adjustPanelUp(panelHeightBottom, bottomSpaceAvailable) {\n        // Browsers ignore fractional scroll offsets, so we need to round.\n        const distanceBelowViewport = Math.round(panelHeightBottom - bottomSpaceAvailable);\n        // Scrolls the panel up by the distance it was extending past the boundary, then\n        // adjusts the offset by that amount to move the panel up into the viewport.\n        this._scrollTop -= distanceBelowViewport;\n        this._offsetY -= distanceBelowViewport;\n        this._transformOrigin = this._getOriginBasedOnOption();\n        // If the panel is scrolled to the very top, it won't be able to fit the panel\n        // by scrolling, so set the offset to 0 to allow the fallback position to take\n        // effect.\n        if (this._scrollTop <= 0) {\n            this._scrollTop = 0;\n            this._offsetY = 0;\n            this._transformOrigin = `50% bottom 0px`;\n        }\n    }\n    /** Adjusts the overlay panel down to fit in the viewport. */\n    _adjustPanelDown(panelHeightTop, topSpaceAvailable, maxScroll) {\n        // Browsers ignore fractional scroll offsets, so we need to round.\n        const distanceAboveViewport = Math.round(panelHeightTop - topSpaceAvailable);\n        // Scrolls the panel down by the distance it was extending past the boundary, then\n        // adjusts the offset by that amount to move the panel down into the viewport.\n        this._scrollTop += distanceAboveViewport;\n        this._offsetY += distanceAboveViewport;\n        this._transformOrigin = this._getOriginBasedOnOption();\n        // If the panel is scrolled to the very bottom, it won't be able to fit the\n        // panel by scrolling, so set the offset to 0 to allow the fallback position\n        // to take effect.\n        if (this._scrollTop >= maxScroll) {\n            this._scrollTop = maxScroll;\n            this._offsetY = 0;\n            this._transformOrigin = `50% top 0px`;\n            return;\n        }\n    }\n    /** Calculates the scroll position and x- and y-offsets of the overlay panel. */\n    _calculateOverlayPosition() {\n        const itemHeight = this._getItemHeight();\n        const items = this._getItemCount();\n        const panelHeight = Math.min(items * itemHeight, SELECT_PANEL_MAX_HEIGHT);\n        const scrollContainerHeight = items * itemHeight;\n        // The farthest the panel can be scrolled before it hits the bottom\n        const maxScroll = scrollContainerHeight - panelHeight;\n        // If no value is selected we open the popup to the first item.\n        let selectedOptionOffset;\n        if (this.empty) {\n            selectedOptionOffset = 0;\n        }\n        else {\n            selectedOptionOffset = Math.max(this.options.toArray().indexOf(this._selectionModel.selected[0]), 0);\n        }\n        selectedOptionOffset += _countGroupLabelsBeforeOption(selectedOptionOffset, this.options, this.optionGroups);\n        // We must maintain a scroll buffer so the selected option will be scrolled to the\n        // center of the overlay panel rather than the top.\n        const scrollBuffer = panelHeight / 2;\n        this._scrollTop = this._calculateOverlayScroll(selectedOptionOffset, scrollBuffer, maxScroll);\n        this._offsetY = this._calculateOverlayOffsetY(selectedOptionOffset, scrollBuffer, maxScroll);\n        this._checkOverlayWithinViewport(maxScroll);\n    }\n    /** Sets the transform origin point based on the selected option. */\n    _getOriginBasedOnOption() {\n        const itemHeight = this._getItemHeight();\n        const optionHeightAdjustment = (itemHeight - this._triggerRect.height) / 2;\n        const originY = Math.abs(this._offsetY) - optionHeightAdjustment + itemHeight / 2;\n        return `50% ${originY}px 0px`;\n    }\n    /** Calculates the height of the select's options. */\n    _getItemHeight() {\n        return this._triggerFontSize * SELECT_ITEM_HEIGHT_EM;\n    }\n    /** Calculates the amount of items in the select. This includes options and group labels. */\n    _getItemCount() {\n        return this.options.length + this.optionGroups.length;\n    }\n}\nMatSelect.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatSelect, deps: null, target: i0.ɵɵFactoryTarget.Component });\nMatSelect.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.3.0\", type: MatSelect, selector: \"mat-select\", inputs: { disabled: \"disabled\", disableRipple: \"disableRipple\", tabIndex: \"tabIndex\" }, host: { attributes: { \"role\": \"combobox\", \"aria-autocomplete\": \"none\", \"aria-haspopup\": \"true\" }, listeners: { \"keydown\": \"_handleKeydown($event)\", \"focus\": \"_onFocus()\", \"blur\": \"_onBlur()\" }, properties: { \"attr.id\": \"id\", \"attr.tabindex\": \"tabIndex\", \"attr.aria-controls\": \"panelOpen ? id + \\\"-panel\\\" : null\", \"attr.aria-expanded\": \"panelOpen\", \"attr.aria-label\": \"ariaLabel || null\", \"attr.aria-required\": \"required.toString()\", \"attr.aria-disabled\": \"disabled.toString()\", \"attr.aria-invalid\": \"errorState\", \"attr.aria-describedby\": \"_ariaDescribedby || null\", \"attr.aria-activedescendant\": \"_getAriaActiveDescendant()\", \"class.mat-select-disabled\": \"disabled\", \"class.mat-select-invalid\": \"errorState\", \"class.mat-select-required\": \"required\", \"class.mat-select-empty\": \"empty\", \"class.mat-select-multiple\": \"multiple\" }, classAttribute: \"mat-select\" }, providers: [\n        { provide: MatFormFieldControl, useExisting: MatSelect },\n        { provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatSelect },\n    ], queries: [{ propertyName: \"customTrigger\", first: true, predicate: MAT_SELECT_TRIGGER, descendants: true }, { propertyName: \"options\", predicate: MatOption, descendants: true }, { propertyName: \"optionGroups\", predicate: MAT_OPTGROUP, descendants: true }], exportAs: [\"matSelect\"], usesInheritance: true, ngImport: i0, template: \"<!--\\n Note that the select trigger element specifies `aria-owns` pointing to the listbox overlay.\\n While aria-owns is not required for the ARIA 1.2 `role=\\\"combobox\\\"` interaction pattern,\\n it fixes an issue with VoiceOver when the select appears inside of an `aria-model=\\\"true\\\"`\\n element (e.g. a dialog). Without this `aria-owns`, the `aria-modal` on a dialog prevents\\n VoiceOver from \\\"seeing\\\" the select's listbox overlay for aria-activedescendant.\\n Using `aria-owns` re-parents the select overlay so that it works again.\\n See https://github.com/angular/components/issues/20694\\n-->\\n<div cdk-overlay-origin\\n     [attr.aria-owns]=\\\"panelOpen ? id + '-panel' : null\\\"\\n     class=\\\"mat-select-trigger\\\"\\n     (click)=\\\"toggle()\\\"\\n     #origin=\\\"cdkOverlayOrigin\\\"\\n     #trigger>\\n  <div class=\\\"mat-select-value\\\" [ngSwitch]=\\\"empty\\\" [attr.id]=\\\"_valueId\\\">\\n    <span class=\\\"mat-select-placeholder mat-select-min-line\\\" *ngSwitchCase=\\\"true\\\">{{placeholder}}</span>\\n    <span class=\\\"mat-select-value-text\\\" *ngSwitchCase=\\\"false\\\" [ngSwitch]=\\\"!!customTrigger\\\">\\n      <span class=\\\"mat-select-min-line\\\" *ngSwitchDefault>{{triggerValue}}</span>\\n      <ng-content select=\\\"mat-select-trigger\\\" *ngSwitchCase=\\\"true\\\"></ng-content>\\n    </span>\\n  </div>\\n\\n  <div class=\\\"mat-select-arrow-wrapper\\\"><div class=\\\"mat-select-arrow\\\"></div></div>\\n</div>\\n\\n<ng-template\\n  cdk-connected-overlay\\n  cdkConnectedOverlayLockPosition\\n  cdkConnectedOverlayHasBackdrop\\n  cdkConnectedOverlayBackdropClass=\\\"cdk-overlay-transparent-backdrop\\\"\\n  [cdkConnectedOverlayPanelClass]=\\\"_overlayPanelClass\\\"\\n  [cdkConnectedOverlayScrollStrategy]=\\\"_scrollStrategy\\\"\\n  [cdkConnectedOverlayOrigin]=\\\"origin\\\"\\n  [cdkConnectedOverlayOpen]=\\\"panelOpen\\\"\\n  [cdkConnectedOverlayPositions]=\\\"_positions\\\"\\n  [cdkConnectedOverlayMinWidth]=\\\"_triggerRect?.width!\\\"\\n  [cdkConnectedOverlayOffsetY]=\\\"_offsetY\\\"\\n  (backdropClick)=\\\"close()\\\"\\n  (attach)=\\\"_onAttached()\\\"\\n  (detach)=\\\"close()\\\">\\n  <div class=\\\"mat-select-panel-wrap\\\" [@transformPanelWrap]>\\n    <div\\n      #panel\\n      role=\\\"listbox\\\"\\n      tabindex=\\\"-1\\\"\\n      class=\\\"mat-select-panel {{ _getPanelTheme() }}\\\"\\n      [attr.id]=\\\"id + '-panel'\\\"\\n      [attr.aria-multiselectable]=\\\"multiple\\\"\\n      [attr.aria-label]=\\\"ariaLabel || null\\\"\\n      [attr.aria-labelledby]=\\\"_getPanelAriaLabelledby()\\\"\\n      [ngClass]=\\\"panelClass\\\"\\n      [@transformPanel]=\\\"multiple ? 'showing-multiple' : 'showing'\\\"\\n      (@transformPanel.done)=\\\"_panelDoneAnimatingStream.next($event.toState)\\\"\\n      [style.transformOrigin]=\\\"_transformOrigin\\\"\\n      [style.font-size.px]=\\\"_triggerFontSize\\\"\\n      (keydown)=\\\"_handleKeydown($event)\\\">\\n      <ng-content></ng-content>\\n    </div>\\n  </div>\\n</ng-template>\\n\", styles: [\".mat-select{display:inline-block;width:100%;outline:none}.mat-select-trigger{display:inline-flex;align-items:center;cursor:pointer;position:relative;box-sizing:border-box;width:100%}.mat-select-disabled .mat-select-trigger{-webkit-user-select:none;user-select:none;cursor:default}.mat-select-value{width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-select-arrow-wrapper{height:16px;flex-shrink:0;display:inline-flex;align-items:center}.mat-form-field-appearance-fill .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-outline .mat-select-arrow-wrapper{transform:translateY(-25%)}.mat-form-field-appearance-standard.mat-form-field-has-label .mat-select:not(.mat-select-empty) .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:none}.mat-select-arrow{width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;margin:0 4px}.mat-form-field.mat-focused .mat-select-arrow{transform:translateX(0)}.mat-select-panel-wrap{flex-basis:100%}.mat-select-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;padding-top:0;padding-bottom:0;max-height:256px;min-width:100%;border-radius:4px;outline:0}.cdk-high-contrast-active .mat-select-panel{outline:solid 1px}.mat-select-panel .mat-optgroup-label,.mat-select-panel .mat-option{font-size:inherit;line-height:3em;height:3em}.mat-form-field-type-mat-select:not(.mat-form-field-disabled) .mat-form-field-flex{cursor:pointer}.mat-form-field-type-mat-select .mat-form-field-label{width:calc(100% - 18px)}.mat-select-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable .mat-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-select-placeholder{color:transparent;-webkit-text-fill-color:transparent;transition:none;display:block}.mat-select-min-line:empty::before{content:\\\" \\\";white-space:pre;width:1px;display:inline-block;visibility:hidden}\\n\"], directives: [{ type: i7.CdkOverlayOrigin, selector: \"[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]\", exportAs: [\"cdkOverlayOrigin\"] }, { type: i8.NgSwitch, selector: \"[ngSwitch]\", inputs: [\"ngSwitch\"] }, { type: i8.NgSwitchCase, selector: \"[ngSwitchCase]\", inputs: [\"ngSwitchCase\"] }, { type: i8.NgSwitchDefault, selector: \"[ngSwitchDefault]\" }, { type: i7.CdkConnectedOverlay, selector: \"[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]\", inputs: [\"cdkConnectedOverlayOrigin\", \"cdkConnectedOverlayPositions\", \"cdkConnectedOverlayPositionStrategy\", \"cdkConnectedOverlayOffsetX\", \"cdkConnectedOverlayOffsetY\", \"cdkConnectedOverlayWidth\", \"cdkConnectedOverlayHeight\", \"cdkConnectedOverlayMinWidth\", \"cdkConnectedOverlayMinHeight\", \"cdkConnectedOverlayBackdropClass\", \"cdkConnectedOverlayPanelClass\", \"cdkConnectedOverlayViewportMargin\", \"cdkConnectedOverlayScrollStrategy\", \"cdkConnectedOverlayOpen\", \"cdkConnectedOverlayDisableClose\", \"cdkConnectedOverlayTransformOriginOn\", \"cdkConnectedOverlayHasBackdrop\", \"cdkConnectedOverlayLockPosition\", \"cdkConnectedOverlayFlexibleDimensions\", \"cdkConnectedOverlayGrowAfterOpen\", \"cdkConnectedOverlayPush\"], outputs: [\"backdropClick\", \"positionChange\", \"attach\", \"detach\", \"overlayKeydown\", \"overlayOutsideClick\"], exportAs: [\"cdkConnectedOverlay\"] }, { type: i8.NgClass, selector: \"[ngClass]\", inputs: [\"class\", \"ngClass\"] }], animations: [matSelectAnimations.transformPanelWrap, matSelectAnimations.transformPanel], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatSelect, decorators: [{\n            type: Component,\n            args: [{ selector: 'mat-select', exportAs: 'matSelect', inputs: ['disabled', 'disableRipple', 'tabIndex'], encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, host: {\n                        'role': 'combobox',\n                        'aria-autocomplete': 'none',\n                        // TODO(crisbeto): the value for aria-haspopup should be `listbox`, but currently it's difficult\n                        // to sync into Google, because of an outdated automated a11y check which flags it as an invalid\n                        // value. At some point we should try to switch it back to being `listbox`.\n                        'aria-haspopup': 'true',\n                        'class': 'mat-select',\n                        '[attr.id]': 'id',\n                        '[attr.tabindex]': 'tabIndex',\n                        '[attr.aria-controls]': 'panelOpen ? id + \"-panel\" : null',\n                        '[attr.aria-expanded]': 'panelOpen',\n                        '[attr.aria-label]': 'ariaLabel || null',\n                        '[attr.aria-required]': 'required.toString()',\n                        '[attr.aria-disabled]': 'disabled.toString()',\n                        '[attr.aria-invalid]': 'errorState',\n                        '[attr.aria-describedby]': '_ariaDescribedby || null',\n                        '[attr.aria-activedescendant]': '_getAriaActiveDescendant()',\n                        '[class.mat-select-disabled]': 'disabled',\n                        '[class.mat-select-invalid]': 'errorState',\n                        '[class.mat-select-required]': 'required',\n                        '[class.mat-select-empty]': 'empty',\n                        '[class.mat-select-multiple]': 'multiple',\n                        '(keydown)': '_handleKeydown($event)',\n                        '(focus)': '_onFocus()',\n                        '(blur)': '_onBlur()',\n                    }, animations: [matSelectAnimations.transformPanelWrap, matSelectAnimations.transformPanel], providers: [\n                        { provide: MatFormFieldControl, useExisting: MatSelect },\n                        { provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatSelect },\n                    ], template: \"<!--\\n Note that the select trigger element specifies `aria-owns` pointing to the listbox overlay.\\n While aria-owns is not required for the ARIA 1.2 `role=\\\"combobox\\\"` interaction pattern,\\n it fixes an issue with VoiceOver when the select appears inside of an `aria-model=\\\"true\\\"`\\n element (e.g. a dialog). Without this `aria-owns`, the `aria-modal` on a dialog prevents\\n VoiceOver from \\\"seeing\\\" the select's listbox overlay for aria-activedescendant.\\n Using `aria-owns` re-parents the select overlay so that it works again.\\n See https://github.com/angular/components/issues/20694\\n-->\\n<div cdk-overlay-origin\\n     [attr.aria-owns]=\\\"panelOpen ? id + '-panel' : null\\\"\\n     class=\\\"mat-select-trigger\\\"\\n     (click)=\\\"toggle()\\\"\\n     #origin=\\\"cdkOverlayOrigin\\\"\\n     #trigger>\\n  <div class=\\\"mat-select-value\\\" [ngSwitch]=\\\"empty\\\" [attr.id]=\\\"_valueId\\\">\\n    <span class=\\\"mat-select-placeholder mat-select-min-line\\\" *ngSwitchCase=\\\"true\\\">{{placeholder}}</span>\\n    <span class=\\\"mat-select-value-text\\\" *ngSwitchCase=\\\"false\\\" [ngSwitch]=\\\"!!customTrigger\\\">\\n      <span class=\\\"mat-select-min-line\\\" *ngSwitchDefault>{{triggerValue}}</span>\\n      <ng-content select=\\\"mat-select-trigger\\\" *ngSwitchCase=\\\"true\\\"></ng-content>\\n    </span>\\n  </div>\\n\\n  <div class=\\\"mat-select-arrow-wrapper\\\"><div class=\\\"mat-select-arrow\\\"></div></div>\\n</div>\\n\\n<ng-template\\n  cdk-connected-overlay\\n  cdkConnectedOverlayLockPosition\\n  cdkConnectedOverlayHasBackdrop\\n  cdkConnectedOverlayBackdropClass=\\\"cdk-overlay-transparent-backdrop\\\"\\n  [cdkConnectedOverlayPanelClass]=\\\"_overlayPanelClass\\\"\\n  [cdkConnectedOverlayScrollStrategy]=\\\"_scrollStrategy\\\"\\n  [cdkConnectedOverlayOrigin]=\\\"origin\\\"\\n  [cdkConnectedOverlayOpen]=\\\"panelOpen\\\"\\n  [cdkConnectedOverlayPositions]=\\\"_positions\\\"\\n  [cdkConnectedOverlayMinWidth]=\\\"_triggerRect?.width!\\\"\\n  [cdkConnectedOverlayOffsetY]=\\\"_offsetY\\\"\\n  (backdropClick)=\\\"close()\\\"\\n  (attach)=\\\"_onAttached()\\\"\\n  (detach)=\\\"close()\\\">\\n  <div class=\\\"mat-select-panel-wrap\\\" [@transformPanelWrap]>\\n    <div\\n      #panel\\n      role=\\\"listbox\\\"\\n      tabindex=\\\"-1\\\"\\n      class=\\\"mat-select-panel {{ _getPanelTheme() }}\\\"\\n      [attr.id]=\\\"id + '-panel'\\\"\\n      [attr.aria-multiselectable]=\\\"multiple\\\"\\n      [attr.aria-label]=\\\"ariaLabel || null\\\"\\n      [attr.aria-labelledby]=\\\"_getPanelAriaLabelledby()\\\"\\n      [ngClass]=\\\"panelClass\\\"\\n      [@transformPanel]=\\\"multiple ? 'showing-multiple' : 'showing'\\\"\\n      (@transformPanel.done)=\\\"_panelDoneAnimatingStream.next($event.toState)\\\"\\n      [style.transformOrigin]=\\\"_transformOrigin\\\"\\n      [style.font-size.px]=\\\"_triggerFontSize\\\"\\n      (keydown)=\\\"_handleKeydown($event)\\\">\\n      <ng-content></ng-content>\\n    </div>\\n  </div>\\n</ng-template>\\n\", styles: [\".mat-select{display:inline-block;width:100%;outline:none}.mat-select-trigger{display:inline-flex;align-items:center;cursor:pointer;position:relative;box-sizing:border-box;width:100%}.mat-select-disabled .mat-select-trigger{-webkit-user-select:none;user-select:none;cursor:default}.mat-select-value{width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-select-arrow-wrapper{height:16px;flex-shrink:0;display:inline-flex;align-items:center}.mat-form-field-appearance-fill .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-outline .mat-select-arrow-wrapper{transform:translateY(-25%)}.mat-form-field-appearance-standard.mat-form-field-has-label .mat-select:not(.mat-select-empty) .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:none}.mat-select-arrow{width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;margin:0 4px}.mat-form-field.mat-focused .mat-select-arrow{transform:translateX(0)}.mat-select-panel-wrap{flex-basis:100%}.mat-select-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;padding-top:0;padding-bottom:0;max-height:256px;min-width:100%;border-radius:4px;outline:0}.cdk-high-contrast-active .mat-select-panel{outline:solid 1px}.mat-select-panel .mat-optgroup-label,.mat-select-panel .mat-option{font-size:inherit;line-height:3em;height:3em}.mat-form-field-type-mat-select:not(.mat-form-field-disabled) .mat-form-field-flex{cursor:pointer}.mat-form-field-type-mat-select .mat-form-field-label{width:calc(100% - 18px)}.mat-select-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable .mat-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-select-placeholder{color:transparent;-webkit-text-fill-color:transparent;transition:none;display:block}.mat-select-min-line:empty::before{content:\\\" \\\";white-space:pre;width:1px;display:inline-block;visibility:hidden}\\n\"] }]\n        }], propDecorators: { options: [{\n                type: ContentChildren,\n                args: [MatOption, { descendants: true }]\n            }], optionGroups: [{\n                type: ContentChildren,\n                args: [MAT_OPTGROUP, { descendants: true }]\n            }], customTrigger: [{\n                type: ContentChild,\n                args: [MAT_SELECT_TRIGGER]\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass MatSelectModule {\n}\nMatSelectModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatSelectModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nMatSelectModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatSelectModule, declarations: [MatSelect, MatSelectTrigger], imports: [CommonModule, OverlayModule, MatOptionModule, MatCommonModule], exports: [CdkScrollableModule,\n        MatFormFieldModule,\n        MatSelect,\n        MatSelectTrigger,\n        MatOptionModule,\n        MatCommonModule] });\nMatSelectModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatSelectModule, providers: [MAT_SELECT_SCROLL_STRATEGY_PROVIDER], imports: [[CommonModule, OverlayModule, MatOptionModule, MatCommonModule], CdkScrollableModule,\n        MatFormFieldModule,\n        MatOptionModule,\n        MatCommonModule] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatSelectModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [CommonModule, OverlayModule, MatOptionModule, MatCommonModule],\n                    exports: [\n                        CdkScrollableModule,\n                        MatFormFieldModule,\n                        MatSelect,\n                        MatSelectTrigger,\n                        MatOptionModule,\n                        MatCommonModule,\n                    ],\n                    declarations: [MatSelect, MatSelectTrigger],\n                    providers: [MAT_SELECT_SCROLL_STRATEGY_PROVIDER],\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_SELECT_CONFIG, MAT_SELECT_SCROLL_STRATEGY, MAT_SELECT_SCROLL_STRATEGY_PROVIDER, MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY, MAT_SELECT_TRIGGER, MatSelect, MatSelectChange, MatSelectModule, MatSelectTrigger, _MatSelectBase, matSelectAnimations };\n","import * as i0 from '@angular/core';\nimport { Component, ViewEncapsulation, ChangeDetectionStrategy, Optional, Inject, ViewChild, Input, NgModule } from '@angular/core';\nimport * as i2 from '@angular/material/core';\nimport { mixinColor, mixinDisabled, mixinDisableRipple, MatRipple, MatRippleModule, MatCommonModule } from '@angular/material/core';\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\nimport * as i1 from '@angular/cdk/a11y';\n\n/** Default color palette for round buttons (mat-fab and mat-mini-fab) */\nconst DEFAULT_ROUND_BUTTON_COLOR = 'accent';\n/**\n * List of classes to add to MatButton instances based on host attributes to\n * style as different variants.\n */\nconst BUTTON_HOST_ATTRIBUTES = [\n    'mat-button',\n    'mat-flat-button',\n    'mat-icon-button',\n    'mat-raised-button',\n    'mat-stroked-button',\n    'mat-mini-fab',\n    'mat-fab',\n];\n// Boilerplate for applying mixins to MatButton.\nconst _MatButtonBase = mixinColor(mixinDisabled(mixinDisableRipple(class {\n    constructor(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n})));\n/**\n * Material design button.\n */\nclass MatButton extends _MatButtonBase {\n    constructor(elementRef, _focusMonitor, _animationMode) {\n        super(elementRef);\n        this._focusMonitor = _focusMonitor;\n        this._animationMode = _animationMode;\n        /** Whether the button is round. */\n        this.isRoundButton = this._hasHostAttributes('mat-fab', 'mat-mini-fab');\n        /** Whether the button is icon button. */\n        this.isIconButton = this._hasHostAttributes('mat-icon-button');\n        // For each of the variant selectors that is present in the button's host\n        // attributes, add the correct corresponding class.\n        for (const attr of BUTTON_HOST_ATTRIBUTES) {\n            if (this._hasHostAttributes(attr)) {\n                this._getHostElement().classList.add(attr);\n            }\n        }\n        // Add a class that applies to all buttons. This makes it easier to target if somebody\n        // wants to target all Material buttons. We do it here rather than `host` to ensure that\n        // the class is applied to derived classes.\n        elementRef.nativeElement.classList.add('mat-button-base');\n        if (this.isRoundButton) {\n            this.color = DEFAULT_ROUND_BUTTON_COLOR;\n        }\n    }\n    ngAfterViewInit() {\n        this._focusMonitor.monitor(this._elementRef, true);\n    }\n    ngOnDestroy() {\n        this._focusMonitor.stopMonitoring(this._elementRef);\n    }\n    /** Focuses the button. */\n    focus(origin, options) {\n        if (origin) {\n            this._focusMonitor.focusVia(this._getHostElement(), origin, options);\n        }\n        else {\n            this._getHostElement().focus(options);\n        }\n    }\n    _getHostElement() {\n        return this._elementRef.nativeElement;\n    }\n    _isRippleDisabled() {\n        return this.disableRipple || this.disabled;\n    }\n    /** Gets whether the button has one of the given attributes. */\n    _hasHostAttributes(...attributes) {\n        return attributes.some(attribute => this._getHostElement().hasAttribute(attribute));\n    }\n}\nMatButton.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatButton, deps: [{ token: i0.ElementRef }, { token: i1.FocusMonitor }, { token: ANIMATION_MODULE_TYPE, optional: true }], target: i0.ɵɵFactoryTarget.Component });\nMatButton.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.3.0\", type: MatButton, selector: \"button[mat-button], button[mat-raised-button], button[mat-icon-button],\\n             button[mat-fab], button[mat-mini-fab], button[mat-stroked-button],\\n             button[mat-flat-button]\", inputs: { disabled: \"disabled\", disableRipple: \"disableRipple\", color: \"color\" }, host: { properties: { \"attr.disabled\": \"disabled || null\", \"class._mat-animation-noopable\": \"_animationMode === \\\"NoopAnimations\\\"\", \"class.mat-button-disabled\": \"disabled\" }, classAttribute: \"mat-focus-indicator\" }, viewQueries: [{ propertyName: \"ripple\", first: true, predicate: MatRipple, descendants: true }], exportAs: [\"matButton\"], usesInheritance: true, ngImport: i0, template: \"<span class=\\\"mat-button-wrapper\\\"><ng-content></ng-content></span>\\n<span matRipple class=\\\"mat-button-ripple\\\"\\n      [class.mat-button-ripple-round]=\\\"isRoundButton || isIconButton\\\"\\n      [matRippleDisabled]=\\\"_isRippleDisabled()\\\"\\n      [matRippleCentered]=\\\"isIconButton\\\"\\n      [matRippleTrigger]=\\\"_getHostElement()\\\"></span>\\n<span class=\\\"mat-button-focus-overlay\\\"></span>\\n\", styles: [\".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:inline-flex;justify-content:center;align-items:center;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}\\n\"], directives: [{ type: i2.MatRipple, selector: \"[mat-ripple], [matRipple]\", inputs: [\"matRippleColor\", \"matRippleUnbounded\", \"matRippleCentered\", \"matRippleRadius\", \"matRippleAnimation\", \"matRippleDisabled\", \"matRippleTrigger\"], exportAs: [\"matRipple\"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatButton, decorators: [{\n            type: Component,\n            args: [{ selector: `button[mat-button], button[mat-raised-button], button[mat-icon-button],\n             button[mat-fab], button[mat-mini-fab], button[mat-stroked-button],\n             button[mat-flat-button]`, exportAs: 'matButton', host: {\n                        '[attr.disabled]': 'disabled || null',\n                        '[class._mat-animation-noopable]': '_animationMode === \"NoopAnimations\"',\n                        // Add a class for disabled button styling instead of the using attribute\n                        // selector or pseudo-selector.  This allows users to create focusabled\n                        // disabled buttons without recreating the styles.\n                        '[class.mat-button-disabled]': 'disabled',\n                        'class': 'mat-focus-indicator',\n                    }, inputs: ['disabled', 'disableRipple', 'color'], encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, template: \"<span class=\\\"mat-button-wrapper\\\"><ng-content></ng-content></span>\\n<span matRipple class=\\\"mat-button-ripple\\\"\\n      [class.mat-button-ripple-round]=\\\"isRoundButton || isIconButton\\\"\\n      [matRippleDisabled]=\\\"_isRippleDisabled()\\\"\\n      [matRippleCentered]=\\\"isIconButton\\\"\\n      [matRippleTrigger]=\\\"_getHostElement()\\\"></span>\\n<span class=\\\"mat-button-focus-overlay\\\"></span>\\n\", styles: [\".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:inline-flex;justify-content:center;align-items:center;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}\\n\"] }]\n        }], ctorParameters: function () {\n        return [{ type: i0.ElementRef }, { type: i1.FocusMonitor }, { type: undefined, decorators: [{\n                        type: Optional\n                    }, {\n                        type: Inject,\n                        args: [ANIMATION_MODULE_TYPE]\n                    }] }];\n    }, propDecorators: { ripple: [{\n                type: ViewChild,\n                args: [MatRipple]\n            }] } });\n/**\n * Material design anchor button.\n */\nclass MatAnchor extends MatButton {\n    constructor(focusMonitor, elementRef, animationMode, \n    /** @breaking-change 14.0.0 _ngZone will be required. */\n    _ngZone) {\n        super(elementRef, focusMonitor, animationMode);\n        this._ngZone = _ngZone;\n        this._haltDisabledEvents = (event) => {\n            // A disabled button shouldn't apply any actions\n            if (this.disabled) {\n                event.preventDefault();\n                event.stopImmediatePropagation();\n            }\n        };\n    }\n    ngAfterViewInit() {\n        super.ngAfterViewInit();\n        /** @breaking-change 14.0.0 _ngZone will be required. */\n        if (this._ngZone) {\n            this._ngZone.runOutsideAngular(() => {\n                this._elementRef.nativeElement.addEventListener('click', this._haltDisabledEvents);\n            });\n        }\n        else {\n            this._elementRef.nativeElement.addEventListener('click', this._haltDisabledEvents);\n        }\n    }\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        this._elementRef.nativeElement.removeEventListener('click', this._haltDisabledEvents);\n    }\n}\nMatAnchor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatAnchor, deps: [{ token: i1.FocusMonitor }, { token: i0.ElementRef }, { token: ANIMATION_MODULE_TYPE, optional: true }, { token: i0.NgZone, optional: true }], target: i0.ɵɵFactoryTarget.Component });\nMatAnchor.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.3.0\", type: MatAnchor, selector: \"a[mat-button], a[mat-raised-button], a[mat-icon-button], a[mat-fab],\\n             a[mat-mini-fab], a[mat-stroked-button], a[mat-flat-button]\", inputs: { disabled: \"disabled\", disableRipple: \"disableRipple\", color: \"color\", tabIndex: \"tabIndex\" }, host: { properties: { \"attr.tabindex\": \"disabled ? -1 : tabIndex\", \"attr.disabled\": \"disabled || null\", \"attr.aria-disabled\": \"disabled.toString()\", \"class._mat-animation-noopable\": \"_animationMode === \\\"NoopAnimations\\\"\", \"class.mat-button-disabled\": \"disabled\" }, classAttribute: \"mat-focus-indicator\" }, exportAs: [\"matButton\", \"matAnchor\"], usesInheritance: true, ngImport: i0, template: \"<span class=\\\"mat-button-wrapper\\\"><ng-content></ng-content></span>\\n<span matRipple class=\\\"mat-button-ripple\\\"\\n      [class.mat-button-ripple-round]=\\\"isRoundButton || isIconButton\\\"\\n      [matRippleDisabled]=\\\"_isRippleDisabled()\\\"\\n      [matRippleCentered]=\\\"isIconButton\\\"\\n      [matRippleTrigger]=\\\"_getHostElement()\\\"></span>\\n<span class=\\\"mat-button-focus-overlay\\\"></span>\\n\", styles: [\".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:inline-flex;justify-content:center;align-items:center;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}\\n\"], directives: [{ type: i2.MatRipple, selector: \"[mat-ripple], [matRipple]\", inputs: [\"matRippleColor\", \"matRippleUnbounded\", \"matRippleCentered\", \"matRippleRadius\", \"matRippleAnimation\", \"matRippleDisabled\", \"matRippleTrigger\"], exportAs: [\"matRipple\"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatAnchor, decorators: [{\n            type: Component,\n            args: [{ selector: `a[mat-button], a[mat-raised-button], a[mat-icon-button], a[mat-fab],\n             a[mat-mini-fab], a[mat-stroked-button], a[mat-flat-button]`, exportAs: 'matButton, matAnchor', host: {\n                        // Note that we ignore the user-specified tabindex when it's disabled for\n                        // consistency with the `mat-button` applied on native buttons where even\n                        // though they have an index, they're not tabbable.\n                        '[attr.tabindex]': 'disabled ? -1 : tabIndex',\n                        '[attr.disabled]': 'disabled || null',\n                        '[attr.aria-disabled]': 'disabled.toString()',\n                        '[class._mat-animation-noopable]': '_animationMode === \"NoopAnimations\"',\n                        '[class.mat-button-disabled]': 'disabled',\n                        'class': 'mat-focus-indicator',\n                    }, inputs: ['disabled', 'disableRipple', 'color'], encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, template: \"<span class=\\\"mat-button-wrapper\\\"><ng-content></ng-content></span>\\n<span matRipple class=\\\"mat-button-ripple\\\"\\n      [class.mat-button-ripple-round]=\\\"isRoundButton || isIconButton\\\"\\n      [matRippleDisabled]=\\\"_isRippleDisabled()\\\"\\n      [matRippleCentered]=\\\"isIconButton\\\"\\n      [matRippleTrigger]=\\\"_getHostElement()\\\"></span>\\n<span class=\\\"mat-button-focus-overlay\\\"></span>\\n\", styles: [\".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:inline-flex;justify-content:center;align-items:center;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}\\n\"] }]\n        }], ctorParameters: function () {\n        return [{ type: i1.FocusMonitor }, { type: i0.ElementRef }, { type: undefined, decorators: [{\n                        type: Optional\n                    }, {\n                        type: Inject,\n                        args: [ANIMATION_MODULE_TYPE]\n                    }] }, { type: i0.NgZone, decorators: [{\n                        type: Optional\n                    }] }];\n    }, propDecorators: { tabIndex: [{\n                type: Input\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass MatButtonModule {\n}\nMatButtonModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatButtonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nMatButtonModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatButtonModule, declarations: [MatButton, MatAnchor], imports: [MatRippleModule, MatCommonModule], exports: [MatButton, MatAnchor, MatCommonModule] });\nMatButtonModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatButtonModule, imports: [[MatRippleModule, MatCommonModule], MatCommonModule] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.3.0\", ngImport: i0, type: MatButtonModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [MatRippleModule, MatCommonModule],\n                    exports: [MatButton, MatAnchor, MatCommonModule],\n                    declarations: [MatButton, MatAnchor],\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MatAnchor, MatButton, MatButtonModule };\n","import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { MatChipsModule } from '@angular/material/chips';\nimport { MatFormFieldModule } from '@angular/material/form-field';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatSelectModule } from '@angular/material/select';\nimport { RouterModule } from '@angular/router';\nimport { CategoriesComponent } from './categories.component';\nimport { MatButtonModule } from '@angular/material/button';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    RouterModule,\n    FormsModule,\n    ReactiveFormsModule,\n    MatChipsModule,\n    MatIconModule,\n    MatFormFieldModule,\n    MatSelectModule,\n    MatButtonModule\n  ],\n  declarations: [CategoriesComponent],\n  exports: [CategoriesComponent],\n})\nexport class CategoriesModule { }\n","export const PAGE_LIMITS = [5, 10, 25, 50];","<section class=\"wrapper\">\n  <mat-chip-list aria-label=\"category selection\">\n    <mat-chip\n      *ngFor=\"let category of categories\"\n      routerLink\n      [queryParams]=\"{ category_ids: category.id }\"\n      queryParamsHandling=\"merge\"\n      [ngClass]=\"{ active: category.id === categoryId }\"\n    >\n      {{ category?.name }}\n    </mat-chip>\n    <mat-chip>\n      <button\n        matSuffix\n        mat-icon-button\n        aria-label=\"Clear\"\n        routerLink\n        [queryParams]=\"{ category_ids: null }\"\n        queryParamsHandling=\"merge\"\n      >\n        <mat-icon>close</mat-icon>\n      </button>\n    </mat-chip>\n  </mat-chip-list>\n  <mat-form-field appearance=\"fill\">\n    <mat-label>Page Limit</mat-label>\n    <mat-select [(ngModel)]=\"pageLimit\" name=\"food\">\n      <mat-option *ngFor=\"let limit of pageLimits\" [value]=\"limit\">\n        {{ limit }}\n      </mat-option>\n    </mat-select>\n  </mat-form-field>\n</section>\n","import { Component, OnInit } from '@angular/core';\nimport { CategoriesRepository, ICategory } from '../communication';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { UntilDestroy, untilDestroyed } from '@ngneat/until-destroy';\nimport { PAGE_LIMITS } from './constants';\n\n@UntilDestroy()\n@Component({\n  selector: 'app-categories',\n  templateUrl: './categories.component.html',\n  styleUrls: ['./categories.component.scss']\n})\nexport class CategoriesComponent implements OnInit {\n  public categories: ICategory[] = [];\n  public categoryId: number | null;\n\n  public pageLimits = PAGE_LIMITS;\n\n  public set pageLimit(value: number) {\n    this._handlePageLimitChanges(value);\n  }\n\n  public get pageLimit(): number {\n    return this._pageLimit;\n  }\n\n  private _pageLimit: number;\n\n  constructor(\n    private readonly _categoriesRepository: CategoriesRepository,\n    private readonly _route: ActivatedRoute,\n    private readonly _router: Router\n  ) { }\n\n  ngOnInit() {\n    this._initCategories();\n    this._subscribeOnRouteParams();\n\n  }\n\n  private _subscribeOnRouteParams(): void {\n    this._route.queryParams\n      .pipe(untilDestroyed(this))\n      .subscribe((params) => {\n        this._pageLimit = Number(params?.limit) || 10;\n        this.categoryId = Number(params?.category_ids) || null;\n      })\n  }\n\n  private _handlePageLimitChanges(limit: number): void {\n    this._router.navigate([], {\n      relativeTo: this._route,\n      queryParams: { limit },\n      queryParamsHandling: 'merge'\n    })\n\n    this._pageLimit = limit;\n  }\n\n  private _initCategories(): void {\n    this._categoriesRepository.getItems()\n      .pipe(untilDestroyed(this))\n      .subscribe(\n        (val: ICategory[]) => this.categories = val,\n        (err) => console.error(err)\n      )\n  }\n\n}\n","import { Component, Input } from '@angular/core';\nimport { ICat } from '../../communication';\n\n@Component({\n  selector: 'app-card',\n  templateUrl: './card.component.html',\n  styleUrls: ['./card.component.scss']\n})\nexport class CardComponent {\n  @Input() item: ICat | undefined;\n}\n","<div class=\"card\">\n  <img [src]=\"item?.url\" alt=\"\">\n</div>","<app-categories></app-categories>\n<section class=\"wrapper\">\n    <mat-spinner *ngIf=\"isLoading\"></mat-spinner>\n    <ul class=\"cats-list\" *ngIf=\"!isLoading\">\n        <li class=\"cats-list-item\" *ngFor=\"let cat of cats\">\n            <app-card [item]=\"cat\"></app-card>\n        </li>\n    </ul>\n</section>\n","import { Component, OnInit } from '@angular/core';\nimport { ActivatedRoute } from '@angular/router';\nimport { UntilDestroy, untilDestroyed } from '@ngneat/until-destroy';\nimport { ICat, ImagesRepository } from '../communication';\n\n@UntilDestroy()\n@Component({\n  selector: 'app-cats',\n  templateUrl: './cats.component.html',\n  styleUrls: ['./cats.component.scss']\n})\nexport class CatsComponent implements OnInit {\n  public cats: ICat[] = [];\n  public isLoading = false;\n\n  private _params: any = {\n    limit: 10\n  }\n\n  constructor(\n    private readonly _imagesRepository: ImagesRepository,\n    private readonly _route: ActivatedRoute,\n  ) { }\n\n  ngOnInit() {\n    this._subscribeOnParamChanges();\n  }\n\n  private _subscribeOnParamChanges(): void {\n    this._route.queryParams\n      .pipe(untilDestroyed(this))\n      .subscribe((params) => {\n        const query = { ...this._params, ...params };\n\n        this._loadImages(query);\n      })\n  }\n\n  private _loadImages(params: any): void {\n    this.isLoading = true;\n\n    this._imagesRepository.getItems(params)\n      .pipe(untilDestroyed(this))\n      .subscribe(\n        (val: ICat[]) => {\n          this.cats = val;\n          this.isLoading = false;\n        },\n        (err) => console.error(err)\n      )\n  }\n\n}\n","import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { MatProgressSpinnerModule } from '@angular/material/progress-spinner';\nimport { RouterModule } from '@angular/router';\nimport { CategoriesModule } from '../categories/categories.module';\nimport { CardComponent } from './card/card.component';\nimport { CatsComponent } from './cats.component';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    RouterModule.forChild([\n      {\n        path: '',\n        component: CatsComponent\n      }\n    ]),\n    CategoriesModule,\n    MatProgressSpinnerModule\n  ],\n  declarations: [CatsComponent, CardComponent]\n})\nexport class CatsModule { }\n"]}